c({"name": "can.util.fixture.make", "params": {"types": {"description": "<p>An array of the fixture names or the singular fixture name.\nIf an array, the first item is the plural fixture name (prefixed with -) and the second\nitem is the singular name.  If a string, it's assumed to be the singular fixture name.  Make\nwill simply add s to the end of it for the plural name. If this parameter is not an array\nor a String the fixture won't be added and only return the generator object.</p>", "type": "Array|String", "optional": false, "order": 0, "name": "types"}, "count": {"description": "<p>the number of items to create</p>", "type": "Number", "optional": false, "order": 1, "name": "count"}, "make": {"description": "<p>a function that will return json data representing the object.  The\nmake function is called back with the id and the current array of items.</p>", "type": "Function", "optional": false, "order": 2, "name": "make"}, "filter": {"description": "<p>(optional) a function used to further filter results. Used for to simulate\nserver params like searchText or startDate.  The function should return true if the item passes the filter,\nfalse otherwise.  For example:</p>\n\n<pre><code>function(item, settings){\n  if(settings.data.searchText){\n       var regex = new RegExp(\"^\"+settings.data.searchText)\n      return regex.test(item.name);\n  }\n}\n</code></pre>", "type": "Function", "optional": false, "order": 3, "name": "filter"}}, "ret": {"description": "<p>A generator object providing fixture functions for <em>findAll</em>, <em>findOne</em>, <em>create</em>,\n<em>update</em> and <em>destroy</em>.</p>", "type": "Object"}, "type": "function", "comment": "<p>Used to make fixtures for findAll / findOne style requests.</p>\n\n<h2>With can.ajax</h2>\n\n<pre><code>//makes a nested list of messages\ncan.fixture.make([\"messages\",\"message\"],1000, function(i, messages){\n  return {\n    subject: \"This is message \"+i,\n    body: \"Here is some text for this message\",\n    date: Math.floor( new Date().getTime() ),\n    parentId : i &lt; 100 ? null : Math.floor(Math.random()*i)\n  }\n})\n//uses the message fixture to return messages limited by offset, limit, order, etc.\ncan.ajax({\n  url: \"messages\",\n  data:{ \n     offset: 100,\n     limit: 50,\n     order: [\"date ASC\"],\n     parentId: 5},\n   },\n   fixture: \"-messages\",\n   success: function( messages ) {  ... }\n});\n</code></pre>\n\n<h2>With can.Model</h2>\n\n<p>You can use can.fixture.make to emulate all Ajax requests made by [can.Model]. With a model like this:</p>\n\n<pre><code> var Todo = can.Model({\n     findAll : 'GET /todos',\n     findOne : 'GET /todos/{id}',\n     create  : 'POST /todos',\n     update  : 'PUT /todos/{id}',\n     destroy : 'DELETE /todos/{id}'\n }, {});\n</code></pre>\n\n<p>And a generated fixture like this:</p>\n\n<pre><code> var store = can.fixture.make(100, function(i) {\n     return {\n         id : i,\n         name : 'Todo ' + i\n     }\n });\n</code></pre>\n\n<p>You can map can.Model requests using the returned store:</p>\n\n<pre><code> can.fixture('GET /todos', store.findAll);\n can.fixture('GET /todos/{id}', store.findOne);\n can.fixture('POST /todos', store.create);\n can.fixture('PUT /todos/{id}', store.update);\n can.fixture('DELETE /todos/{id}', store.destroy);\n</code></pre>", "parents": ["can.util.fixture"], "src": "can/util/fixture/fixture.js", "line": 526, "children": []})