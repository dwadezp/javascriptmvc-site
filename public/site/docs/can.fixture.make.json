c({"name": "can.fixture.make", "type": "function", "comment": "<p><code>can.fixture.make</code> is used for findAll / findOne style requests.</p>\n\n<h2>With can.ajax</h2>\n\n<pre><code>//makes a nested list of messages\ncan.fixture.make([\"messages\",\"message\"], 1000,\n function(i, messages){\n  return {\n    subject: \"This is message \"+i,\n    body: \"Here is some text for this message\",\n    date: Math.floor( new Date().getTime() ),\n    parentId : i &lt; 100 ? null : Math.floor(Math.random()*i)\n  }\n})\n//uses the message fixture to return messages limited by\n// offset, limit, order, etc.\ncan.ajax({\n  url: \"messages\",\n  data: {\n     offset: 100,\n     limit: 50,\n     order: [\"date ASC\"],\n     parentId: 5},\n   },\n   fixture: \"-messages\",\n   success: function( messages ) {  ... }\n});\n</code></pre>\n\n<h2>With can.Model</h2>\n\n<p><code>can.fixture.make</code> returns a model store that offers <code>findAll</code>, <code>findOne</code>, <code>create</code>,\n<code>update</code> and <code>destroy</code> fixture functions you can map to a [can.Model] Ajax request.\nConsider a model like this:</p>\n\n<pre><code> var Todo = can.Model({\n     findAll : 'GET /todos',\n     findOne : 'GET /todos/{id}',\n     create  : 'POST /todos',\n     update  : 'PUT /todos/{id}',\n     destroy : 'DELETE /todos/{id}'\n }, {});\n</code></pre>\n\n<p>And an unnamed generated fixture like this:</p>\n\n<pre><code> var store = can.fixture.make(100, function(i) {\n     return {\n         id : i,\n         name : 'Todo ' + i\n     }\n });\n</code></pre>\n\n<p>You can map can.Model requests using the return value of <code>can.fixture.make</code>:</p>\n\n<pre><code> can.fixture('GET /todos', store.findAll);\n can.fixture('GET /todos/{id}', store.findOne);\n can.fixture('POST /todos', store.create);\n can.fixture('PUT /todos/{id}', store.update);\n can.fixture('DELETE /todos/{id}', store.destroy);\n</code></pre>", "parents": ["can.fixture"], "params": {"types": {"order": 0, "description": "<p>An array of the fixture names or the singular fixture name.\nIf an array, the first item is the plural fixture name (prefixed with -) and the second\nitem is the singular name.  If a string, it's assumed to be the singular fixture name.  Make\nwill simply add s to the end of it for the plural name. If this parameter is not an array\nor a String the fixture won't be added and only return the generator object.</p>", "name": "types", "type": "Array|String", "optional": false}, "count": {"order": 1, "description": "<p>the number of items to create</p>", "name": "count", "type": "Number", "optional": false}, "make": {"order": 2, "description": "<p>a function that will return the JavaScript object. The\nmake function is called back with the id and the current array of items.</p>", "name": "make", "type": "Function", "optional": false}, "filter": {"order": 3, "description": "<p>(optional) a function used to further filter results. Used for to simulate\nserver params like searchText or startDate.\nThe function should return true if the item passes the filter,\nfalse otherwise. For example:</p>\n\n<pre><code>function(item, settings){\n  if(settings.data.searchText){\n       var regex = new RegExp(\"^\"+settings.data.searchText)\n      return regex.test(item.name);\n  }\n}\n</code></pre>", "name": "filter", "type": "Function", "optional": false}}, "ret": {"description": "<p>A generator object providing fixture functions for <em>findAll</em>, <em>findOne</em>, <em>create</em>,\n<em>update</em> and <em>destroy</em>.</p>", "type": "Object"}, "src": "can/util/fixture/fixture.js", "line": 358, "children": []})