c({"name": "organizing", "type": "page", "comment": "<p>The secret to building large apps is to NEVER build\nlarge apps.  Break up your applications into small \npieces.  Then assemble those testable, bite-sized pieces \ninto your big application.</p>\n\n<p>DoneJS is built with this pattern in\nmind. As opposed to a single flat 'scripts' folder, \nDoneJS breaks up your app into\nmanageable, isolated modules. This tutorial discusses\nthe reasons for doing this and patterns for doing it.</p>\n\n<h2>Why</h2>\n\n<p>Traditionally JavaScript, CSS and static resources were seen as second-class\ncitizens when compared to server code.  JavaScript code was put in a single\nflat 'scripts' folder that looked like:</p>\n\n<pre><code>button.js\njquery.ui.calendar.js\ncontactmanager.js\ntabs.js\njquery.js\nnav.js\nresizer.js\n\\test\n  button_test.js\n  contactmanager.js\n  tabs_test.js\n  nav_test.js\n</code></pre>\n\n<p>This was OK for a limited amount of JavaScript; however; client code\nincreasingly represents a larger percentage of an \napp's codebase.  What works for 10 files does not work for 100.</p>\n\n<p>Complicating matters, an individual JavaScript file might have dependencies on\nnon-JavaScript resources.  It's easy to imagine a menu needing \na specific stylesheet, images, or [can.view client side template] to run.</p>\n\n<p>Spreading these dependencies across images, styles, templates etc folders\nleads to bad organization and potentially bad performance. For example, it can be\nhard to know if a particular style rule is needed.</p>\n\n<h3>The Fix</h3>\n\n<p>DoneJS gives each resource you author it's own folder. Typically,\nthe folder will hold the resource, the its demo page, test page,\ntest script, and any other files specific to that resource.</p>\n\n<p>For example, a tabs folder might look like:</p>\n\n<pre><code>\\tabs\n  tabs.js        - the code for a tabs widget \n  tabs.html      - a demo page\n  funcunit.html  - a test page\n  tabs_test.js   - test code\n  tabs.css       - css for the tab\n</code></pre>\n\n<p>The idea is that we can work on <code>tabs.js</code> in complete isolation.</p>\n\n<h2>How</h2>\n\n<p>Before we discuss best practices for organizing your application, a little\nthroat clearing ...</p>\n\n<blockquote>\n  <p>Every app is different. Providing a single folder structure for all applications is impossible. However, there are several useful  patterns that when understood can keep your application under control. DoneJS is extremely flexible so use your best judgement!</p>\n</blockquote>\n\n<p>This guide walks you through starting with a small-ish example app and where you would add\nfeatures over time.  Before the example, it's good to know some JavaScript terminology:</p>\n\n<h3>App and Library Folders</h3>\n\n<p>In general, a DoneJS application is divided into two root folders: an app folder and\nlibrary folder. The app folder code typically <em>steals</em> and configures <em>library</em> code.</p>\n\n<h4>Application Folder</h4>\n\n<p>The application (or app) folder houses code specific to a particular \napplication.  The code in this folder is very unlikely to be\nused in other places.  The folder name reflects the name of the application \nbeing built.  </p>\n\n<h4>Library Folders</h4>\n\n<p>A library folder is for general code that \ncan be reused across several applications. It is the perfect place for\nreusable controls like a tabs widget. Typically folder names reflect\nthe name of the organization building the controls.  </p>\n\n<h3>Resource Types</h3>\n\n<p>An application is comprised of various resources.  DoneJS's code generators can \nbe used to create these resources.</p>\n\n<p><strong>Model</strong> - A model represents a set of services.  Typically, they exist within an application\nfolder's <code>models</code> directory and are used to request data by other controls.</p>\n\n<p>Generate a model like:</p>\n\n<pre><code>js jquery\\generate\\model cms\\models\\image\n</code></pre>\n\n<p><strong>Controller</strong> - A controller is a widget or code that combines and organizes\nseveral widgets.  Reusable widgets are added to library folders.  Controllers specific\nto an application should be put in a folder within an application folder.</p>\n\n<p>Generate a controller like:</p>\n\n<pre><code>js jquery\\generate\\controller jupiter\\tabs\n</code></pre>\n\n<p><strong>Plugin</strong> - A plugin is a low-level reusable module such as a special event or dom extension.\nIt does not typically have a visible component.  These should be added to library folders.</p>\n\n<pre><code>js jquery\\generate\\plugin jupiter\\range\n</code></pre>\n\n<h2>Example Application</h2>\n\n<p>The example is a content management system that organizes 'videos', 'images', and \n'articles' under a tabbed layout.  For each content type, the user needs\nto be able to edit a selected item of that type.</p>\n\n<p><img class='image_tag' src='tutorials/cms.png' /></p>\n\n<p>If the application's name is <strong>cms</strong> and it is built by <strong>Jupiter</strong>, a basic version's\nfolder structure might look like:</p>\n\n<pre><code>\\cms\n  \\models    - models for the CMS\n  \\views     - views to configure the grid\n  cms.js\n\\jupiter\n  \\tabs      - a basic tabs widget\n  \\edit      - binds a form to edit a model instance\n  \\grid      - a configurable grid\n    \\views\n</code></pre>\n\n<p>This basic version assumes that we can configure the grid and edit widget\nenough to produces the desired functionality. In this case,\n<code>cms/cms.js</code> might look like:</p>\n\n<pre><code>// load dependencies\nsteal('jupiter/tabs',\n      'jupiter/grid',\n      'jupiter/create',\n      './models/image',\n      './models/video',\n      './models/article',function(){\n\n  // add tabs to the page\n  $('#tabs').jupiter_tabs();\n\n  // Configure the video grid\n  $('#videos').jupiter_grid({\n    model: Cms.Models.Video,\n    view: \"//cms/views/videos.ejs\"\n  })\n\n  // listen for when a video is selected\n  .bind('select' , function(ev, video){\n\n    // update the edit form with the selected \n    // video's attributes\n    $('#videoEdit').jupiter_edit({ model: video });\n  });\n\n  // Do the same for images and articles\n  $('#images').jupiter_grid({\n    model: Cms.Models.Image,\n    view: \"//cms/views/images.ejs\"\n  }).bind('select' , function(ev, image){\n    $('#imageEdit').jupiter_edit({ model: image });\n  });\n\n  $('#articles').jupiter_grid({\n    model: Cms.Models.Article,\n    view: \"//cms/views/article.ejs\"\n  }).bind('select' , function(ev, article){\n    $('#articleEdit').jupiter_edit({ model: article });\n  });\n\n})\n</code></pre>\n\n<p>Notice that the <code>cms.js</code> configures the grid and edit widgets with\nthe cms folder's models and views.  This represents an ideal separation between\napp specific code and reusable widgets.  However, it's extremely rare that \nwidgets are able to provide all the functionality an app needs to meet its\nrequirements.</p>\n\n<h3>More complexity</h3>\n\n<p>Eventually, you won't be able to configure abstract widgets to satisfy\nthe requirements of your application.  For example, you might need to \nadd specific functionality around listing and editing videos (such as a thumbnail editor).</p>\n\n<p>This is application specific functionality and belongs \nin the application folder.  We'll encapsulate it in a controller for each type:</p>\n\n<pre><code>\\cms\n  \\articles - the articles tab\n  \\images   - the images tab\n  \\videos   - the videos tab\n  \\models  \n  \\views     \n  cms.js\n\\jupiter\n  \\thumbnail\n  \\tabs     \n  \\edit      \n  \\grid      \n    \\views\n</code></pre>\n\n<p><code>cms/cms.js</code> now looks like:</p>\n\n<pre><code>steal('cms/articles',\n      'cms/images',\n      'cms/videos',\n      'jupiter/tabs',\n      function(){\n\n  $('#tabs').jupiter_tabs();\n\n  // add the video grid\n  $('#videos').cms_videos()\n\n  // Do the same for images and articles\n  $('#images').cms_images();\n  $('#articles').cms_articles();\n\n})\n</code></pre>\n\n<p><code>cms/articles/articles.js</code> might look like:</p>\n\n<pre><code>steal('jupiter/grid',\n      'jupiter/edit',\n      'jquery/controller', \n      'jquery/view/ejs',\n      'jupiter/thumbnail',\n      function(){\n\n  $.Controller('Cms.Articles',\n  {\n    listensTo: [\"select\"]\n  },\n  {\n    init : function(){\n      // draw the html for the tab\n      this.element.html('//cms/articles/views/init.ejs',{});\n\n      // configure the grid\n      this.find('.grid').jupiter_grid({\n        model: Cms.Models.Article,\n        view: \"//cms/articles/views/article.ejs\"\n      });\n    },\n\n    // when the grid triggers a select event\n    \"select\" : function(el, ev, article){\n\n      // add or update the edit control\n      this.find('.edit').jupiter_edit({ model: article })\n\n      // add the thumbnail editor\n          .find('.thumbs').jupiter_thumbnail();\n    }\n  });\n\n});\n</code></pre>\n\n<h3>Adding leaves to the tree</h3>\n\n<p>In the previous example, we moved most of the code in <code>cms/cms.js</code> into\nan articles, images, and videos plugin.  Each of these plugins should\nwork independently from each other, have it's own tests and demo page.</p>\n\n<p>Communication between these high-level\ncontrols should be configured in <code>cms/cms.js</code>.</p>\n\n<p>Essentially, as your needs become more specific, you are encouraged to \nnest plugins within each other.</p>\n\n<p>In this example, after separating out each type into it's own plugin, you might\nwant to split the type into edit and grid controls.  The resulting \nfolder structure would look like:</p>\n\n<pre><code>\\cms\n  \\articles\n    \\grid\n    \\edit\n  \\images\n    \\grid\n    \\edit   \n  \\videos\n    \\grid\n    \\edit   \n  \\models  \n  \\views     \n  cms.js\n\\jupiter\n  \\thumbnail\n  \\tabs     \n  \\edit      \n  \\grid      \n</code></pre>\n\n<p><code>cms/articles/articles.js</code> might now look like:</p>\n\n<pre><code>steal('cms/articles/grid',\n      'cms/articles/edit',\n      'jquery/controller',\n      'jquery/view/ejs',\n      function(){\n\n  $.Controller('Cms.Articles',\n  {\n    listensTo: [\"select\"]\n  },\n  {\n    init : function(){\n      // draw the initial html\n      this.element.html('//cms/articles/views/init.ejs',{});\n\n      // create the articles grid\n      this.find('.grid').cms_articles_grid();\n    },\n    \"select\" : function(el, ev, article){\n\n      // update the articles edit control\n      this.find('.edit').cms_articles_edit({ model: article });\n    }\n  });\n})\n</code></pre>\n\n<p>DoneJS encourages you to organize your application folder as a tree.\nThe leaves of the tree are micro-controls that perform a specific task (such as\nallowing the editing of videos).  </p>\n\n<p>Higher-order controls (<code>cms/articles/articles.js</code>) combine leaves and other nodes \ninto more complex functionality.  The root of the application is the application file \n(<code>cms/cms.js</code>).  It combines and configures all high-level widgets.</p>\n\n<p>In general, low-level controls use jQuery.trigger to send messages 'up' to higher-order\ncontrols.  Higher-order controls typically call methods on lower-level controls</p>\n\n<p>The Cms.Articles control listening to a 'select' event produced by\nCms.Articles.Grid and creating (or updating) the Cms.Articles.Edit control\nis a great example of this.</p>\n\n<p>The situation where this breaks down is usually when a 'state' needs to be shared and communicated\nacross several controls.  [jQuery.Observe] and client [jQuery.Model models] are useful \nfor this situation.</p>\n\n<h2>Conclusion</h2>\n\n<p>This is an extremely abstract article, but hopefully illustrates a few\nimportant trends of DoneJS organization:</p>\n\n<ul>\n<li>Put code specific to an app in the application folder.</li>\n<li>Put reusable plugins, widgets, and other code into library folders.</li>\n<li>Fill out the tree.</li>\n</ul>", "title": "Organizing Your App", "parents": ["tutorials"], "order": 6, "src": "tutorials/organizing.md", "children": []})