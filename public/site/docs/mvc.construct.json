c({"name": "mvc.construct", "type": "page", "comment": "<p>Can's Control and Model inherit from its Class helper - [Can.Construct]. To create a class, call <code>can.Construct([NAME, classProperties, ] instanceProperties])</code>.</p>\n\n<pre><code>can.Construct(\"Animal\",{\n  breathe : function(){\n     console.log('breathe'); \n  }\n});\n</code></pre>\n\n<p>In the example above, instances of Animal have a <code>breathe()</code> method. We can create a new <code>Animal</code> instance and call <code>breathe()</code> on it like:</p>\n\n<pre><code>var man = new Animal();\nman.breathe();\n</code></pre>\n\n<p>If you want to extend the construct, simply call the the base construct with the sub-class's name and properties:</p>\n\n<pre><code>Animal(\"Dog\",{\n  wag : function(){\n    console.log('wag');\n  }\n})\n\nvar dog = new Dog;\ndog.wag();\ndog.breathe();\n</code></pre>\n\n<h3>Instantiation</h3>\n\n<p>When a new construct instance is created, it calls the class's <code>init</code> method with the arguments passed to the constructor function:</p>\n\n<pre><code>can.Construct('Person',{\n  init : function(name){\n    this.name = name;\n  },\n  speak : function(){\n    return \"I am \"+this.name+\".\";\n  }\n});\n\nvar payal = new Person(\"Payal\");\nassertEqual( payal.speak() ,  'I am Payal.' );\n</code></pre>\n\n<h3>Calling base methods</h3>\n\n<p>Call base methods either by calling <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/Apply\">apply</a>\non the prototype method:</p>\n\n<pre><code>Person(\"ClassyPerson\", {\n  speak : function(){\n    return \"Salutations, \" + Person.prototype.speak.apply(this, arguments);\n  }\n});\n</code></pre>\n\n<p>Or when using the [can.Construct.super] plugin with <code>this._super</code>:</p>\n\n<pre><code>Person(\"ClassyPerson\", {\n  speak : function(){\n    return \"Salutations, \"+this._super();\n  }\n});\n\nvar fancypants = new ClassyPerson(\"Mr. Fancy\");\nassertEquals( fancypants.speak() , 'Salutations, I am Mr. Fancy.')\n</code></pre>\n\n<h3>Proxies</h3>\n\n<p>Use the [can.Construct.proxy] plugin to create a function that has 'this' set appropriately (similar to <a href=\"http://api.jquery.com/jQuery.proxy/\">jQuery.proxy</a>). The following creates a clicky class that counts how many times it was clicked:</p>\n\n<pre><code>can.Construct(\"Clicky\",{\n  init : function(){\n    this.clickCount = 0;\n  },\n  clicked: function(){\n    this.clickCount++;\n  },\n  listen: function(el){\n    el.click( this.proxy('clicked') );\n  }\n})\n\nvar clicky = new Clicky();\nclicky.listen( $('#foo') );\nclicky.listen( $('#bar') ) ;\n</code></pre>\n\n<h3>Static Inheritance</h3>\n\n<p>Construct lets you define inheritable static properties and methods.  The following allows us to retrieve a person instance from the server by calling <code>Person.findOne(ID, success(person) )</code>.  Success is called back with an instance of Person, which has the <code>speak</code> method.</p>\n\n<pre><code>can.Construct(\"Person\",{\n  findOne : function(id, success){\n    can.ajax({\n        url : '/person/'+id,\n        method : 'GET'\n    }).done(function(attrs){\n      success( new Person( attrs ) );\n    })\n  }\n},{\n  init : function(attrs){\n    can.extend(this, attrs)\n  },\n  speak : function(){\n    return \"I am \"+this.name+\".\";\n  }\n})\n\nPerson.findOne(5, function(person){\n  assertEqual( person.speak(), \"I am Payal.\" );\n})\n</code></pre>\n\n<h3>Introspection</h3>\n\n<p>Construct provides namespacing and access to the name of the class and namespace object:</p>\n\n<pre><code>can.Construct(\"Bitovi.Person\");\n\nBitovi.Person.shortName; //-&gt; 'Person'\nBitovi.Person.fullName;  //-&gt; 'Bitovi.Person'\nBitovi.Person.namespace; //-&gt; Bitovi\n\nvar person = new Bitovi.Person();\n\nperson.constructor.shortName; //-&gt; 'Person'\n</code></pre>\n\n<h3>Model example</h3>\n\n<p>Putting it all together, we can make a basic ORM-style model layer.  Just by inheriting from Model, we can request data from REST services and get it back wrapped in instances of the inheriting Model.</p>\n\n<pre><code>can.Construct(\"Model\",{\n  findOne : function(id, success){\n    can.ajax({\n        url : '/'+this.fullName.toLowerCase()+'/'+id,\n        method : 'GET'\n    }).done(this.proxy(function(attrs){\n     success( new this( attrs ) );\n  })\n  }\n},{\n  init : function(attrs){\n    $.extend(this, attrs)\n  }\n})\n\nModel(\"Person\",{\n  speak : function(){\n    return \"I am \"+this.name+\".\";\n  }\n});\n\nPerson.findOne(5, function(person){\n  alert( person.speak() );\n});\n\nModel(\"Task\")\n\nTask.findOne(7,function(task){\n  alert(task.name);\n})\n</code></pre>\n\n<p>This is similar to how CanJS's model layer works. Please continue to [mvc.model Model].</p>", "title": "Construct", "parents": ["mvc"], "order": 0, "src": "tutorials/mvc/mvc.construct.md", "children": []})