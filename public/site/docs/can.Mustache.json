c({"name": "can.Mustache", "type": "class", "comment": "<p>can.Mustache provides logic-less templates with live binding when used with <a href=\"#can_observe\">can.Observes</a>.</p>\n\n<p>can.Mustache is designed to help seperate logic out of your view code without\nsacrifices.</p>\n\n<p>Mustache and Handlebar templates are compatible with can.Mustache, \nso you can import existing templates and automagically start live-binding.</p>\n\n<h2>Demos</h2>\n\n<ul>\n<li><a href=\"http://addyosmani.github.com/todomvc/labs/architecture-examples/canjs/\">TodoMVC</a> is a project which offers the same Todo application implemented using MV* concepts in most of the popular JavaScript MV* frameworks of today.</li>\n</ul>\n\n<h2>Getting Started</h2>\n\n<p>Mustache templates looks similar to normal HTML except\nthey contain contain keys for inserting data into the template\nand sections to enumerate and/or filter the enclosed template blocks.</p>\n\n<p>For example, the following renders a welcome header for\na user and displays the number of messages.</p>\n\n<p><strong>Mustache Template</strong></p>\n\n<pre><code>&lt;script id=\"template\" type=\"text/mustache\"&gt;\n    &lt;h1&gt;Welcome {{user}}!&lt;/h1&gt;\n    &lt;p&gt;\n        {{#if messages}}\n            You have {{messages}} new messages.\n        {{else}}\n            You no messages.\n        {{/if}}\n    &lt;/p&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>The Mustache sytax is the <code>{{  }}</code> magic tags above.</p>\n\n<p><strong>JavaScript</strong></p>\n\n<pre><code>var data = new can.Observe({\n    user: 'Tina Fey',\n    messages: 0\n});\n\nvar template = can.view(\"#template\", data)\n\ncan.$(document.body).append(template);\n</code></pre>\n\n<p>it will render:</p>\n\n<pre><code>&lt;h1&gt;Welcome Tina Fey!&lt;/h1&gt;\n&lt;p&gt;You no messages.&lt;/p&gt;\n</code></pre>\n\n<p>Now if you want to use live-binding to update your template, you can do:</p>\n\n<pre><code>data.attr('message', 5)\n</code></pre>\n\n<p>which will re-render the paragraph tag to say:</p>\n\n<pre><code>&lt;p&gt;You have 5 new messages.&lt;/p&gt;\n</code></pre>\n\n<h2>Escaping Values</h2>\n\n<p>Mustache will escape values enclosed in a <code>{{  }}</code> expression.  If you would\nlike Mustache to return the value without escaping, use the <code>{{{  }}}</code> expression.</p>\n\n<p>For example, the follow double expression.</p>\n\n<pre><code>{\n    friend: \"&lt;strong&gt;Justin&lt;/strong&gt;\"\n}\n\n{{friend}}\n</code></pre>\n\n<p>would return:</p>\n\n<pre><code>&amp;lt;strong&amp;gt;Justin&amp;lt;/strong&amp;gt;\n</code></pre>\n\n<p>whereas if the template was:</p>\n\n<pre><code>{{{friend}}}\n</code></pre>\n\n<p>it would return:</p>\n\n<pre><code>&lt;strong&gt;Justin&lt;/strong&gt;\n</code></pre>\n\n<h2>Paths and Context</h2>\n\n<p>When Mustache is resolving a object in a section, it sets the current\ncontext to the value for which its iterating. For example:</p>\n\n<pre><code>{\n    friends: [ 'Austin' ]\n}\n\n{{#friends}}\n    {{.}}\n{{/friends}}\n</code></pre>\n\n<p>The <code>.</code> would represent the 'Austin' value in the array.</p>\n\n<p>Internally, Mustache keeps a stack of contexts as the template dives\ndeeper into nested sections and helpers.  If a key is not found within \nthe current context, Mustache will look for the key in the parent context\nand so on until it resolves the object or reaches the parent most object. <br />\nFor example:</p>\n\n<pre><code>{\n    family: [\n        {\n            name: 'Austin',\n            sisters: [\n                {\n                    name: 'Katherine'\n                }\n            ],\n            brothers: [\n                {\n                    name: 'Justin'\n                }\n            ]\n        }\n    ]\n}\n\n{{#family}\n    {{#brothers}}\n        {{#sisters}}\n            {{name}}\n        {{/sisters}}\n    {{/brothers}}\n{{/family}}\n</code></pre>\n\n<p>Since <code>sisters</code> isn't in the context of the brothers array,\nit jumps up to the family object and resolves sisters there.</p>\n\n<h2>Template Acquisition</h2>\n\n<p>There are number of ways you can acquire templates such as: raw text,\nURL, or script tags in the markup.</p>\n\n<p><strong>Raw Text</strong></p>\n\n<p>You can process plain text by passing an object with a <code>text</code>\nattribute containing your template and it will return a document fragment back.</p>\n\n<pre><code>var template = \"My body lies over the {{.}}\";\nvar fragment = new can.Mustache({ text: template })\n                .render('water');\ncan.append(can.$(document.body), can.view.frag(fragment));\n</code></pre>\n\n<p><strong>Script Tags</strong></p>\n\n<p>You can place your templates in your HTML document.\nSet the <code>type</code> to <code>text/mustache</code> and the <code>id</code> as a unique\nkey Mustache will use to look it up.</p>\n\n<pre><code>&lt;script id=\"mytemplate\" type=\"text/mustache\"&gt;\n    My body lies over the {{.}}\n&lt;/script&gt;\n\nvar template = can.view(\"#mytemplate\", 'water');\ncan.$(document.body).append(template);\n</code></pre>\n\n<p><strong>URL</strong></p>\n\n<p>You can define templates in their own files and have Mustache fetch the \nfiles on demand.  This is the preferred way since it will keep your application\nnicely organized seperating views from logic code. </p>\n\n<pre><code>var template = can.view('//lib/views/mytemplate.mustache', \n                dataToPass)\ncan.$(document.body).append(template);\n</code></pre>\n\n<p>Since this makes XHR requests, in a big application with lots of views\nthis could be a performance concern.  You should create a build step to \nconcatenate and include all of the views in one file for high performance production\ninstances.  If you are using Steal, it will do this automatically at build \nfor you.</p>\n\n<p><strong>Registering Partials</strong></p>\n\n<p>You can call <code>can.view.registerView</code> to register\na partial template you can call from inside another Mustache template.</p>\n\n<pre><code>can.view.registerView('myTemplate', \"My body lies over {{.}}\")\n</code></pre>\n\n<p>Then later in my view I can do:</p>\n\n<pre><code>{{&gt;myTemplate}}\n</code></pre>\n\n<p>and it will apply the current context to my new template.  For more\ninformation goto the Partials section.</p>\n\n<h2>Sections</h2>\n\n<p>Sections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  here are four different types of sections.</p>\n\n<h3>Falseys or Empty Arrays</h3>\n\n<p>If the value returns a <code>false</code>, <code>undefined</code>, <code>null</code>, <code>\"\"</code> or <code>[]</code> we consider\nthat a <em>falsey</em> value.</p>\n\n<p>If the value is falsey, the section will <strong>NOT</strong> render the block.</p>\n\n<pre><code>{ \n    friends: false\n}\n\n{{#friends}}\n    Never shown!\n{{/friends}}\n</code></pre>\n\n<h3>Arrays</h3>\n\n<p>If the value is a non-empty array, sections will iterate over the \narray of items, rendering the items in the block.</p>\n\n<p>For example, if I have a list of friends, I can iterate\nover each of those items within a section.</p>\n\n<pre><code>{ \n    friends: [ \n        { name: \"Austin\" }, \n        { name: \"Justin\" } \n    ] \n}\n\n&lt;ul&gt;\n    {{#friends}}\n        &lt;li&gt;{{name}}&lt;/li&gt;\n    {{/friends}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>which would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;Austin&lt;/li&gt;\n    &lt;li&gt;Justin&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>Reminder: It will reset the current context to the value for which its iterating.\nSee the context section for more information.</p>\n\n<h3>Truthys</h3>\n\n<p>When the value is non-falsey object but not a list, it is considered truthy and will be used \nas the context for a single rendering of the block.</p>\n\n<pre><code>{\n    friends: { name: \"Jon\" }\n}\n\n{{#friends}}\n    Hi {{name}}\n{{/friends}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>Hi Jon!\n</code></pre>\n\n<h3>Inverted</h3>\n\n<p>Inverted sections match falsey values. An inverted section \nsyntax is similar to regular sections except it begins with a caret rather than a pound. If the value referenced is falsey, the section will render.</p>\n\n<pre><code>{\n    friends: []\n}\n\n&lt;ul&gt;\n    {{#friends}}\n        &lt;/li&gt;{{name}}&lt;/li&gt;\n    {{/friends}}\n    {{^friends}}\n        &lt;li&gt;No friends.&lt;/li&gt;\n    {{/friends}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;No friends.&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>Comments</h2>\n\n<p>Comments, which do not appear in template output, begin a bang (!).</p>\n\n<pre><code>&lt;h1&gt;My friend is {{!Brian}}&lt;/h1&gt;\n</code></pre>\n\n<p>Will render:</p>\n\n<pre><code>&lt;h1&gt;My friend is &lt;/h1&gt;\n</code></pre>\n\n<h2>Partials</h2>\n\n<p>Partials are templates embedded in other templates which execute at runtime. <br />\nPartials begin with a greater than sign, like <code>{{&gt;my_partial}}</code>.  </p>\n\n<p>Partials are rendered at runtime, so recursive partials are possible but make sure you avoid infinite loops. They also inherit the calling context.</p>\n\n<p>For example, this template and partial:</p>\n\n<p><strong>base.mustache</strong></p>\n\n<pre><code>&lt;h2&gt;Names&lt;/h2&gt;\n{{#names}}\n    {{&gt;user}}\n{{/names}}\n</code></pre>\n\n<p><strong>user.mustache</strong></p>\n\n<pre><code>&lt;strong&gt;{{name}}&lt;/strong&gt;\n</code></pre>\n\n<p>The resulting expanded template at render time would look like:</p>\n\n<pre><code>&lt;h2&gt;Names&lt;/h2&gt;\n{{#names}}\n    &lt;strong&gt;{{name}}&lt;/strong&gt;\n{{/names}}\n</code></pre>\n\n<p>See the template acquisition section for more information on\nfetching partials.</p>\n\n<h2>Helpers</h2>\n\n<p>Helpers allow you to register functions that can be called \nfrom any context in a template. </p>\n\n<p>Mustache includes a number of built-in helpers that are listed below\nbut you can register your own helper too.</p>\n\n<h3>if</h3>\n\n<p>In addition to truthy/falsey evaluation with sections, you can use an \nexplicit <code>if</code> condition to render a block.</p>\n\n<pre><code>{\n    friends: true\n}\n\n{{#if friends}}\n    I have friends!\n{{/if}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>I have friends!\n</code></pre>\n\n<p><code>if</code> acts similarly to a truthy <code>{{#section}}</code>.</p>\n\n<h3>else</h3>\n\n<p>When using <code>if</code> or a custom helper, you can specify the inverse\nof the evaluation by using the <code>else</code> helper.</p>\n\n<pre><code>{\n    friend: false\n}\n\n&lt;ul&gt;\n    {{#if friends}}\n        &lt;/li&gt;{{name}}&lt;/li&gt;\n    {{else}}\n        &lt;li&gt;No friends.&lt;/li&gt;\n    {{/if}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;No friends.&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p><code>else</code> acts similarly to a falsey <code>{{^inverse}}</code>, but only applies when used within another helper.</p>\n\n<p>In this case, using the <code>if</code>/<code>else</code> helpers simplify your template by not requiring extra sections to be specified.</p>\n\n<h3>unless</h3>\n\n<p>The <code>unless</code> helper evaluates the inverse of the value of the key and renders \nthe block between the helper and the slash.</p>\n\n<pre><code>{\n    friends: []\n}\n\n{{#unless friends}}\n    You don't have any friends!\n{{/unless}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>You don't have any friends!\n</code></pre>\n\n<p><code>unless</code> acts similarly to a falsey <code>{{^inverse}}</code>.</p>\n\n<h3>each</h3>\n\n<p>You can use the <code>each</code> helper to iterate over an array of items and\nrender the block between the helper and the slash.</p>\n\n<p>Like sections, it will reset the current context to the value for which its iterating.\nSee the context section for more information.</p>\n\n<pre><code>{ \n    friends: [ \n        { name: \"Austin\" }, \n        { name: \"Justin\" } \n    ] \n}\n\n&lt;ul&gt;\n    {{#each friends}}\n        &lt;li&gt;{{name}}&lt;/li&gt;\n    {{/each}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>which would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;Austin&lt;/li&gt;\n    &lt;li&gt;Justin&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h3>with</h3>\n\n<p>Mustache typically applies the context passed in the section at runtime.  However,\nyou can override this context by using the <code>with</code> helper.</p>\n\n<p>For example, using the <code>with</code> helper I shift the context to the friends object.</p>\n\n<pre><code>{\n    name: \"Austin\"\n    friends: 1\n}\n\n\n&lt;h1&gt;Hi {{name}}&lt;/h1&gt;\n{{#with friends}}\n    &lt;p&gt;You have {{.}} new friend!&lt;/p&gt;\n{{/with}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;h1&gt;Hi Austin&lt;/h1&gt;\n&lt;p&gt;You have 1 new friend!&lt;/p&gt;\n</code></pre>\n\n<h3>Element Callbacks</h3>\n\n<p>When rendering HTML with views, you often want to call some JavaScript\nsuch as intializing a jQuery plugin on the new HTML.</p>\n\n<p>Mustache makes it easy to define this code in the markup.  Using the\n<a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:arrow_function_syntax\">ES5 Arrow Syntax</a> \nwe define the element we are going to pass followed by the arrow\nand the function we want to execute on the element.</p>\n\n<pre><code>&lt;div class=\"tabs\" {{(el) -&gt; el.jquery_tabs()}}&gt;&lt;/div&gt;\n</code></pre>\n\n<p>After rendering the HTML, <code>jquery_tabs</code> will be called on the tabs div.</p>\n\n<h3>Data Associations</h3>\n\n<p>You can attach data to an element easily by calling the <code>data</code> helper.\nCall <code>data</code> followed by the attribute name you want to attach it as.</p>\n\n<pre><code>{\n    name: 'Austin'\n}\n\n&lt;ul&gt;\n    &lt;li id=\"foo\" {{data 'person'}}&gt;{{name}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>Now I can access my object by doing:</p>\n\n<pre><code>var nameObject = can.$('#foo').data('person');\n</code></pre>\n\n<p>It automatically attaches the data to the\nelement using [can.data] and the implied context of <code>this</code>.</p>\n\n<h3>Registering Helpers</h3>\n\n<p>You can register your own helper with the <code>Mustache.registerHelper</code> method.</p>\n\n<p>Localization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and \nreturns the localized value using \n<a href=\"https://github.com/jquery/globalize\">jQuery Globalize</a>.</p>\n\n<pre><code>Mustache.registerHelper('l10n', function(str, options){\n    return Globalize != undefined \n        ? Globalize.localize(str) \n        : str;\n});\n</code></pre>\n\n<p>Now in my template, I invoke the helper by calling the helper\nname followed by any arguments I'd like to pass.</p>\n\n<pre><code>&lt;span&gt;{{l10n 'mystring'}}&lt;/span&gt;\n</code></pre>\n\n<p>will render:</p>\n\n<pre><code>&lt;span&gt;my string localized&lt;/span&gt;\n</code></pre>\n\n<p><strong>Multiple Arguments</strong></p>\n\n<p>You can pass multiple arguments just by putting a space between\nthat and the previous argument like so:</p>\n\n<pre><code>{{helper 'cat' 'hat'}}\n\nMustache.registerHelper('helper', function(arg1, arg2, options){\n    // arg1 -&gt; 'cat'\n    // arg2 -&gt; 'hat'\n});\n</code></pre>\n\n<p><strong>Evaluating Helpers</strong></p>\n\n<p>If you want to use a helper with a section, you need to call \n<code>options.fn(context)</code> in your return statement. This will return a \nstring with the resulting evaluated section.</p>\n\n<p>Similarly, you can call <code>options.inverse(context)</code> to evaluate the \ntemplate between an <code>{{else}}</code> magic tag and the closing magic tag.</p>\n\n<p>For example, when a route matches the string passed to our\nrouting helper it will show/hide the text.</p>\n\n<pre><code>Mustache.registerHelper('routing', function(str, options){\n    if (can.route.attr('filter') === str)\n        return options.fn(this);\n    }\n});\n\n{{#routing 'advanced'}}\n    You have applied the advanced filter.\n{{/routing}}\n</code></pre>\n\n<p><strong>Advanced Helpers</strong></p>\n\n<p>Helpers can be passed normal objects, native objects like numbers and strings, as well as a hash object. The hash object will be an object literal containing all ending arguments using the <code>key=value</code> syntax. The hash object will be provided to the helper as <code>options.hash</code>. Additionally, when using sections with the helper, you can set a custom context by passing the object instead of <code>this</code>.</p>\n\n<pre><code>Mustache.registerHelper('exercise', function(group, action, \n                                        num, options){\n    if (group &amp;&amp; group.length &gt; 0 &amp;&amp; action &amp;&amp; num &gt; 0) {\n        return options.fn({\n            group: group,\n            action: action,\n            where: options.hash.where,\n            when: options.hash.when,\n            num: num\n        });\n    }\n    else {\n        return options.inverse(this);\n    }\n});\n\n{{#exercise pets 'walked' 3 where='around the block' when=time}}\n    Along with the {{#group}}{{.}}, {{/group}}\n    we {{action}} {{where}} {{num}} times {{when}}.\n{{else}}\n    We were lazy today.\n{{/exercise}}\n\n{\n    pets: ['cat', 'dog', 'parrot'],\n    time: 'this morning'\n}\n</code></pre>\n\n<p>This would output:</p>\n\n<pre><code>Along with the cat, dog, parrot, we walked around the block \n3 times this morning.\n</code></pre>\n\n<p>Whereas, an empty data object would output:</p>\n\n<pre><code>We were lazy today.\n</code></pre>\n\n<h2>Live binding</h2>\n\n<p>Live binding is templates that update themselves as the data \nused in the magic tags change.</p>\n\n<p>It's very common as the page is interacted with that the underlying \ndata represented in the page changes.  Typically, you have callbacks \nin your AJAX methods or events and then update the content of your \ncontrols manually.</p>\n\n<p>In the first example of the documentation, we have a \nsimple user welcome screen.  In this example, we create a <code>can.Observe</code>\nobject and pass it into the template.</p>\n\n<pre><code>&lt;h1&gt;Welcome {{user}}!&lt;/h1&gt;\n&lt;p&gt;\n    {{#if messages}}\n        You have {{messages}} new messages.\n    {{else}}\n        You no messages.\n    {{/messages}}\n&lt;/p&gt;\n\nvar data = new can.Observe({\n    user: 'Tina Fey',\n    messages: 0\n});\n\nvar template = can.view(\"#template\", data);\n</code></pre>\n\n<p>The template evaluates the <code>messages</code> variable as if\nit were a regular object we created.  Since we have \nno message it will render:</p>\n\n<pre><code>&lt;h1&gt;Welcome Tina Fey!&lt;/h1&gt;\n&lt;p&gt;You no messages.&lt;/p&gt;\n</code></pre>\n\n<p>Now say we have a request that updates\nthe <code>messages</code> attribute to have <code>5</code> messages.  We \ncall the <code>.attr</code> method on the <code>can.Observe</code> to update\nthe attribute to the new value.</p>\n\n<pre><code>data.attr('message', 5)\n</code></pre>\n\n<p>After <code>can.Observe</code> recieves this update, it will\nupdate the paragraph tag to reflect the new value.</p>\n\n<pre><code>&lt;p&gt;You have 5 new message.&lt;/p&gt;\n</code></pre>\n\n<p>For more information visit the [can.Observe].</p>", "parents": ["canjs"], "test": "can/view/mustache/test/qunit.html", "src": "can/view/mustache/mustache.md", "children": []})