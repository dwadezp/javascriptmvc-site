C({"name": "steal.browser", "params": {"options": {"description": "", "type": "Object", "optional": false, "order": 0, "name": "options"}, "type": {"description": "", "type": "", "optional": false, "order": 1, "name": "type"}}, "ret": {"type": "undefined", "description": ""}, "type": "function", "comment": "<p>steal.browser is an abstraction layer for browser drivers.  There is currently support for \nenvjs, phantomjs, and selenium.  Each driver implements an API that includes open, bind, trigger, \nevaluate, and injectJS.  There is also a small client component that is loaded by steal.js.</p>\n\n<p>The initial bootstrap of steal.browser works like this:\n1. steal.browser is used to open a page.  The page's URL is appended with \n?mode=commandline&amp;browser=phantomjs (or whatever driver is being used).\n2. On the client, steal.js does a check for these URL params.  If they're \nfound, steal loads steal/browser/phantomjs/client.js.  Client.js is a small file that implements\nmethods used for evaluating code and triggering events.\n3. Client.js loads jquery.js, runs $.holdReady(true) (to prevent the app from initializing), and \nruns steal.client.trigger('clientloaded') (to notify the server that the browser's client.js has \nloaded.\n4. Now, the server can perform any startup logic it needs, like using injectJS to load files or \nevaluating code.  Whenever its done, it runs this.evaluate(function(){ $.holdReady(false); }).\n5. Document ready is fired on the client, and the application starts up.  Its important to note \nthat any app using steal.browser can't trigger browser events until after document.ready.  This is \nrequired because the server needs to have a chance to load its own code and prevent race conditions.</p>", "src": "../steal/browser/browser.js", "children": []})