C({"name": "writing", "type": "page", "comment": "<p><p>Writing tests is super easy and follows this pattern:</p></p>\n\n<ol>\n  <li>Open a page with [FuncUnit.static.open S.open].\n\n<pre><code class='javascript'>S.open(\"//myapp/myapp.html\")</code></pre>  </li>\n  <li>Do some things\n\n<pre><code class='javascript'>//click something\nS('#myButton').click()\n\n//type something\nS('#myInput').type(\"hello\")</code></pre>  </li>\n\n  <li>Wait for the page to change:\n\n<pre><code class='javascript'>//Wait until it is visible\nS('#myMenu').visible()\n\n//wait until something exists\nS('#myArea').exists()</code></pre>  </li>\n  <li>Check your page in a callback:\n\n<pre><code class='javascript'>S('#myMenu').visible(function(){\n  //check that offset is right\n  equals(S('#myMenu').offset().left, 500, \n    \"menu is in the right spot\");\n})</code></pre>  </li>\n</ol>\n\n<h2>Actions, Waits, and Getters</h2>\n\n<p>FuncUnit supports three types of commands: asynchronous actions and waits, \nand synchronous getters.</p>\n\n<p><b>Actions</b> are used to simulate user behavior such as clicking, typing, moving the mouse.</p>\n\n<p><b>Waits</b> are used to pause the test script until a condition has been met.</p>\n\n<p><b>Getters</b> are used to get information about elements in the page</p>\n\n<p>Typically, a test looks like a series of action and wait commands followed by qUnit test of\nthe result of a getter command.  Getter commands are almost always in a action or wait callback.</p>\n\n<h3>Actions</h3>\n\n<p>Actions simulate user behavior.  FuncUnit provides the following actions:</p>\n\n<ul>\n<li><code>[FuncUnit.static.open open]</code> - opens a page.</li>\n<li><code>[FuncUnit.prototype.click click]</code> - clicks an element (mousedown, mouseup, click).</li>\n<li><code>[FuncUnit.prototype.dblclick dblclick]</code> - two clicks followed by a dblclick.</li>\n<li><code>[FuncUnit.prototype.rightClick rightClick]</code> - a right mousedown, mouseup, and contextmenu.</li>\n<li><code>[FuncUnit.prototype.type type]</code> - types characters into an element.</li>\n<li><code>[FuncUnit.prototype.move move]</code> - mousemove, mouseover, and mouseouts from one element to another.</li>\n<li><code>[FuncUnit.prototype.drag drag]</code> - a drag motion from one element to another.</li>\n<li><code>[FuncUnit.prototype.scroll scroll]</code> - scrolls an element.</li>\n</ul>\n\n<p>Actions run asynchronously, meaning they do not complete all their events immediately. <br />\nHowever, each action is queued so that you can write actions (and waits) linearly.</p>\n\n<p>The following might simulate typing and resizing a \"resizable\" textarea plugin:</p>\n\n<pre><code class='javascript'>S.open('resizableTextarea.html');\n\nS('textarea').click().type(\"Hello World\");\n\nS('.resizer').drag(\"+20 +20\");</code></pre>\n\n<h3>Getters</h3>\n\n<p>Getters are used to test the conditions of the page.  Most getter commands correspond to a jQuery\nmethod of the same name.  The following getters are provided:</p>\n\n<table style='font-family: monospace'>\n<tr>\n    <th colspan='2'>Dimensions</th> <th>Attributes</th> <th>Position</th> <th>Selector</th> <th>Style</th>\n</tr>\n<tr>\n    <td>[FuncUnit.prototype.width width]</td>\n    <td>[FuncUnit.prototype.height height]</td> \n    <td>[FuncUnit.prototype.attr attr]</td> \n    <td>[FuncUnit.prototype.position position]</td> \n    <td>[FuncUnit.prototype.size size]</td> \n    <td>[FuncUnit.prototype.css css]</td>\n</tr>\n<tr>\n    <td>[FuncUnit.prototype.innerWidth innerWidth]</td>\n    <td>[FuncUnit.prototype.innerHeight innerHeight]</td>\n    <td>[FuncUnit.prototype.hasClass hasClass]</td>\n    <td>[FuncUnit.prototype.offset offset]</td>\n    <td>[FuncUnit.prototype.exists exists]</td>\n    <td>[FuncUnit.prototype.visible visible]</td>\n</tr>\n<tr>\n    <td>[FuncUnit.prototype.outerWidth outerWidth]</td>\n    <td>[FuncUnit.prototype.outerHeight outerHeight]</td>\n    <td>[FuncUnit.prototype.val val]</td>\n    <td>[FuncUnit.prototype.scrollLeft scrollLeft]</td>\n    <td>[FuncUnit.prototype.missing missing]</td>\n    <td>[FuncUnit.prototype.invisible invisible]</td>\n</tr>\n<tr>\n    <td colspan='2'></td>\n    <td>[FuncUnit.prototype.text text]</td> \n    <td>[FuncUnit.prototype.scrollTop scrollTop]</td>\n</tr>\n<tr>\n    <td colspan='2'></td>\n    <td>[FuncUnit.prototype.html html]</td>\n</tr>\n</table>\n\n<p>Since getters run synchronously, it's important that they happen after the action or wait command completes.\nThis is why getters are typically found in an action or wait command's callback:</p>\n\n<p>The following performs a drag, then checks that the textarea is 20 pixels taller after the drag.</p>\n\n<pre><code class='javascript'>S.open('resizableTextarea.html');\n\nvar txtarea = S('textarea'), //save textarea reference\n    startingWidth = txtarea.width(), // save references to width and height\n    startingHeight = txtarea.height();\n\nS('.resizer').drag(\"+20 +20\", function(){\n  equals(txtarea.width(), \n         startingWidth, \n         \"width stays the same\");\n\n  equals(txtarea.height(), \n         startingHeight+20, \n         \"height got bigger\");\n});</code></pre>\n\n<h3>Waits</h3>\n\n<p>Waits are used to wait for a specific condition to be met before continuing to the next wait or\naction command.  Like actions, waits execute asynchronously.  They can be given a callback that runs after \ntheir wait condition is met.</p>\n\n<h4>Wait conditions</h4>\n\n<p>Every getter commands can become a wait command when given a check value or function. <br />\nFor example, the following waits until the width of an element is 200 pixels and tests its offset.</p>\n\n<pre><code class='javascript'>var sm = S(\"#sliderMenu\");\nsm.width( 200, function(){\n\n  var offset = sm.offset();\n  equals( offset.left, 200)\n  equals( offset.top, 200)\n})</code></pre>\n\n<h4>Wait functions</h4>\n\n<p>You can also provide a test function that when true, continues to the next action or wait command.\nThe following is equivalent to the previous example:</p>\n\n<pre><code class='javascript'>var sm = S(\"#sliderMenu\");\n\nsm.width(\n  function( width ) {\n    return width == 200;\n  }, \n  function(){\n    var offset = sm.offset();\n    equals( offset.left, 200)\n    equals( offset.top, 200)\n  }\n)</code></pre>\n\n<div class='whisper'>Notice that the test function is provided the width of the element to use to check.</div>\n\n<h4>Timeouts</h4>\n\n<p>By default, wait commands will wait a 10s timeout period.  If the condition isn't true after that time, the test will fail.  You \ncan provide your own timeout for each wait condition as the parameter after the wait condition.  For example, the following will check \nif \"#trigger\" contains \"I was triggered\" for 5 seconds before failing the test.</p>\n\n<pre><code class='javascript'>(\"#trigger\").text(\"I was triggered\", 5000)</code></pre>\n\n<h4>Timer waits</h4>\n\n<p>In addition to all the jQuery-like wait functions, FuncUnit provides [FuncUnit.static.wait S.wait], which waits a timeout before continuing. <br />\nThis function should be used with CAUTION.  You should almost never need it, because its presence means brittle tests that depend on unreliable \ntiming conditions.  Much better than a time based wait is a wait that depends on a page condition (like a menu element appearing).</p>", "title": "2. Writing FuncUnit Tests", "parents": ["FuncUnit"], "src": "../funcunit/pages/writing.js", "children": []})