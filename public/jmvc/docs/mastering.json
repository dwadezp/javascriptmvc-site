C({"name": "mastering", "type": "page", "comment": "<p>Now that we've introduced the commands, this section will dive deeper into the challenges faced while writing FuncUnit tests and \nsome best practices.</p>\n\n<h3>1. Asynchronous vs synchronous commands</h3>\n\n<p>Most FuncUnit commands (all actions and waits) run asynchronously.  This means when a .click() or .visible() method \nruns, it doesn't actually perform a click or check for visible, but rather adds its method to a queue.  After the first method \nin the queue completes, the next one runs.  For example:</p>\n\n<pre><code class='javascript'>S(\".foo\").click();\nS(\".bar\").visible();\nS(\".myinput\").type(\"abc\");</code></pre>\n\n<p>In this example, a click and a wait are added to the queue.  The click runs (it is asynchronous).  When it completes, \nFuncUnit checks if \".bar\" is visible (and keeps checking until it is).  When this condition becomes true, the next command \nin the queue runs, which types \"abc\".</p>\n\n<p>The reason they are asynchronous is to let you write linear FuncUnit tests without needing nested callbacks \nfor every command.  As a result, tou can't set breakpoints in these methods, but there are other debugging methods.  </p>\n\n<p>Assertions and getters are synchronous commands.  Usually these commands are placed in callbacks for waits and actions.  You \ncan set breakpoints in them and inspect the current state of your page.  </p>\n\n<h3>2. The S method</h3>\n\n<p>Its important to realize the S command is NOT the $ command.  It is named S because it acts similarly, but it does not \nreturn a jQuery collection, and you can't call any jQuery methods on the result.</p>\n\n<p>However, the S method accepts any valid jQuery selector, allows chaining, and lets you call many jQuery like methods on it \n(see the Getters section above).</p>\n\n<p>The reason S is not $ is because when in Selenium mode, the test runs in Rhino, sending commands across Selenium into \nthe browser.  So S(\".foo\") sends JSON to the browser via Selenium that is later used as a parameter for $.  Using $ wouldn't work, since only \ntext can be sent across the Selenium bridge, not objects.</p>\n\n<h3>3. Finding the right wait</h3>\n\n<p>After a user clicks or types in your page, something in your page changes.  Something might appear, disappear, get wider, slide left, or show text. <br />\nA good text will take into account what changes after an action, and perform a wait on that condition.  A bad test simply uses S.wait(1000) to wait \n1 second before the next command.  This is error prone, because under certain conditions, the page might be slower than 1 second, causing your test to \nbreak.</p>\n\n<p>Finding the right wait makes your test bullet proof.</p>\n\n<h3>4. Debugging tests</h3>\n\n<p>Since you can't set breakpoints and step through actions/waits, you might wonder how you can effectively debug.  Here are a few techniques.</p>\n\n<h4>1. Simplify</h4>\n\n<p>If a test isn't working, comment out all other tests and even all commands after the one thats giving you trouble.  Run the test.  If it does what you expect, \nuncomment one more command and run again.  You can focus on the one part of your test thats giving you trouble.</p>\n\n<h4>2. Breakpoints in callbacks</h4>\n\n<p>Waits and actions accept a callback that run after they complete.  Inside, you can set breakpoints and inspect your page.  You can also use console.logs \nin callbacks to check conditions that are hard to inspect.</p>\n\n<h4>3. Use FuncUnit's logs</h4>\n\n<p>Check Firebug's console and you'll during every command, it spits out what its doing.  If a selector isn't working, go to your app window, and use jQuery in the \nconsole to debug the selector.</p>\n\n<h3>5. Reuse test code</h3>\n\n<p>Often while writing tests for an app, you'll notice steps that need to happen over and over.  For example, you need to click a tab in a tab widget and type in an input \nto get to the screen you want to test.  You can easily create test helper functions, which allow you to DRY your tests a bit.  For example:</p>\n\n<pre><code class='javascript'>var openTab = function(tabName){\n    S(\".tab:contains('\"+tabName+\"')\").click();\n    S(\".content\").visible();\n}</code></pre>\n\n<h3>6. Do you need assertions?</h3>\n\n<p>As you write tests you'll begin to notice that assertions, while they give you a warm fuzzy feeling, aren't really all that necessary.  You can perform waits for \nthe same conditions you'd check in assertions, your code looks more linear and readable without callbacks, and your tests will still fail if the waits fail.</p>\n\n<p>For example, the following are equivalent:</p>\n\n<pre><code class='javascript'>// wait for 5 li elements to be present\nS(\".menu li\").size(5);\n\n// check if there are 5 li elements\nS(\".menu\").exists(function(){\n    equals(S(\".menu li\").size(), 5, \"there are 5 li's\");\n})</code></pre>\n\n<h3>7. Working with frames</h3>\n\n<p>If your application makes use of iframes, providing a name attribute for your iframes will make testing easier.  The second parameter of S is either the number or \nname of your iframe:</p>\n\n<pre><code class='javascript'>// click \".foo\" in the frame with name=\"myframe\"\nS(\".foo\", \"myframe\").click();</code></pre>\n\n<p>If you're testing the interaction that causes the iframe to load, don't forget to perform a wait on some condition in the frame that signifies it has completed loading.</p>\n\n<h3>8. Solving login</h3>\n\n<p>When testing an application that requires login, the pattern that seems to work is using a login test that only runs in Selenium mode.  When running in browser, \ndevelopers will already be logged in, so the test can be skipped.  In Selenium however, a new browser instance is opened, so login is required.  Here's an \nexample of a login test that does this:</p>\n\n<pre><code class='javascript'>test(\"login test\", function () {\n    if (navigator.userAgent.match(/Rhino/)) {\n        S.open(\"/login\")\n        S(\"#username\").exists().click().type(\"superadmin\")\n        S(\"#password\").exists().click().type(\"password\")\n        S(\".submit input\").exists().click()\n\n        // wait for next page to load\n        S(\".content\").visible(function () {\n            ok(true, \"logged in\");\n        })\n    } else {\n        ok(true, \"assuming you are logged in\");\n    }\n})</code></pre>\n\n<h3>9. Use non-brittle selectors</h3>\n\n<p>To make your tests as readable and future proof as possible, try to choose jQuery selectors that are both easy to understand and not likely to change.  For example:</p>\n\n<h4>Good selector</h4>\n\n<pre><code class='javascript'>S(\".contact:contains('Brian')\");</code></pre>\n\n<h4>Bad selector</h4>\n\n<pre><code class='javascript'>S(\".contact:eq(4)\");</code></pre>\n\n<h3>10. Use pseudocode</h3>\n\n<p>Despite FuncUnit's easy to learn API, when you start to write a test, you're thinking in terms of user interactions, not jQuery selectors.  So the easiest way to \nwrite a test is to start with a method full of pseudocode, then fill in the selectors and commands.</p>\n\n<p>For example:</p>\n\n<pre><code class='javascript'>// click the top link\n// wait for the edit form to appear\n// click the first input, type Chicago\n// click submit\n// wait for the list to appear</code></pre> ", "title": "2.1. Mastering the FuncUnit API", "parents": ["FuncUnit"], "src": "../funcunit/pages/mastering.js", "children": []})