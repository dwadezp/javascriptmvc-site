c({"name": "can.Observe.validations", "type": "page", "comment": "<p>The <code>can/observe/validations</code> plugin provides validations on observes. Validations\nare setup on constructor functions that inherit from [can.Observe]. Call\nvalidation functions in <code>init</code>.</p>\n\n<p>THe following validates the <code>birthday</code> attribute in Contacts:</p>\n\n<pre><code>can.Observe(\"Contact\",{\n    init : function(){\n        // validates that birthday is in the future\n        this.validate(\"birthday\",function(birthday){\n            if(birthday &gt; new Date){\n                return \"your birthday needs to be in the past\"\n            }\n        })\n    }\n},{});\n\nvar contact = new Contact({birthday: new Date(2012,0) })\n</code></pre>\n\n<p>Use [can.Observe::errors]<code>( [attrs...], newVal )</code> to read errors\nor to test if setting a value would create an error:</p>\n\n<pre><code>contact.errors() //-&gt; null - there are no errors\n\ncontact.errros(\"birthday\", \n               new Date(3013,0) ) \n               //-&gt; [\"your birthday needs to be in the past\"] \n\ncontact.attr(\"birthday\", new Date(3013,0) )\n\ncontact.errors() \n    //-&gt; {\n    //     birthday: [\"your birthday needs to be in the past\"]\n    //   }\n</code></pre>\n\n<p>*Note: Its important to include this plugin before you include other plugins that \nextend Observe so that prototype chain is extended correctly.</p>\n\n<h2>Validation Methods</h2>\n\n<p>There are several built-in validation methods so you don't have to define your own in all cases like in the birthday example above.</p>\n\n<ul>\n<li><strong>validate</strong> Validates each of the specified attributes with the given function.</li>\n<li><strong>validateFormatOf</strong> Validates where the values of specified attributes are of the correct form by matching it against the regular expression provided.    </li>\n<li><strong>validateInclusionOf</strong> Validates whether the values of the specified attributes are available in a particular array.    </li>\n<li><strong>validateLengthOf</strong> Validates that the specified attributes' lengths are in the given range.    </li>\n<li><strong>validatePresenceOf</strong> Validates that the specified attributes are not blank.    </li>\n<li><strong>validateRangeOf</strong> Validates that the specified attributes are in the given numeric range.</li>\n</ul>\n\n<h2>Error Method</h2>\n\n<p>Runs the validations on this model. You can also pass it an array of attributes to run only those attributes. It returns nothing if there are no errors, or an object of errors by attribute.</p>\n\n<p>To use validations, it's suggested you use the model/validations plugin.</p>\n\n<pre><code>can.Observe(\"Task\",{\n    init : function(){\n        this.validatePresenceOf(\"dueDate\")\n    }\n},{});\n\nvar task = new Task(),\n    errors = task.errors()\n\nerrors.dueDate[0] //-&gt; \"can't be empty\"\n</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>Use [can.Observe::bind] to listen to error messages:</p>\n\n<pre><code>contact.bind(\"error\", function(ev, attr, errors){\n    // attr = \"birthday\"\n    // errors = { birthday: \n    //      [\"your birthday needs to be in the past\"] }\n})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>Click a person's name to update their birthday.  If you put the date\nin the future, say the year 2525, it will report back an error.</p>\n\n<div class='demo_wrapper' data-demo-src='can/observe/validations/validations.html'></div>", "plugin": "can/observe/validations", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=can/observe/validations/validations.js", "test": "can/observe/validations/qunit.html", "parents": ["can.Observe"], "src": "can/observe/validations/validations.md", "children": []})