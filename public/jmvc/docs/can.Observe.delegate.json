c({"name": "can.Observe.delegate", "type": "page", "comment": "<p>Listens for changes in a child attribute(s) from the parent. The child attribute\ndoes not have to exist.</p>\n\n<pre><code>// create an observable\nvar observe = can.Observe({\n    foo : {\n        bar : \"Hello World\"\n    }\n})\n\n //listen to changes on a property\n observe.delegate(\"foo.bar\",\"change\", \n    function(ev, prop, how, newVal, oldVal){\n           // foo.bar has been added, set, or removed\n           this //-&gt; \n });\n\n // change the property\n observe.attr('foo.bar',\"Goodbye Cruel World\")\n</code></pre>\n\n<p>Delegate will listen on the object until you call <em>undelegate</em> to remove the event handler.</p>\n\n<pre><code>observe.undelegate(\"name\",\"set\", function(){ ... })\n</code></pre>\n\n<h2>Types of events</h2>\n\n<p>Delegate lets you listen to add, set, remove, and change events on property.</p>\n\n<h3>Add</h3>\n\n<p>An add event is fired when a new property has been added.</p>\n\n<pre><code> var o = new can.Control({});\n o.delegate(\"name\",\"add\", function(ev, value){\n   // called once\n   can.$('#name').show()\n })\n o.attr('name',\"Justin\")\n o.attr('name',\"Brian\");\n</code></pre>\n\n<p>Listening to add events is useful for 'setup' functionality (in this case\nshowing the <code>#name</code> element).</p>\n\n<h3>Set</h3>\n\n<p>Set events are fired when a property takes on a new value.  set events are\nalways fired after an add.</p>\n\n<pre><code>o.delegate(\"name\",\"set\", function(ev, value){\n    // called twice\n    can.$('#name').text(value)\n})\n\no.attr('name',\"Justin\")\no.attr('name',\"Brian\");\n</code></pre>\n\n<h3>Remove</h3>\n\n<p>Remove events are fired after a property is removed.</p>\n\n<pre><code>o.delegate(\"name\",\"remove\", function(ev){\n    // called once\n    can.$('#name').text(value)\n})\n\no.attr('name',\"Justin\");\no.removeAttr('name');\n</code></pre>\n\n<h2>Wildcards - matching multiple properties</h2>\n\n<p>Sometimes, you want to know when any property within some part \nof an observe has changed. Delegate lets you use wildcards to \nmatch any property name.  The following listens for any change\non an attribute of the params attribute:</p>\n\n<pre><code>var o = can.Control({\n    options : {\n        limit : 100,\n        offset: 0,\n        params : {\n            parentId: 5\n        }\n    }\n})\n\no.delegate('options.*','change', function(){\n    alert('1');\n})\n\no.delegate('options.**','change', function(){\n    alert('2');\n})\n\n// alerts 1\n// alerts 2\no.attr('options.offset',100)\n\n// alerts 2\no.attr('options.params.parentId',6);\n</code></pre>\n\n<p>Using a single wildcard (<code>*</code>) matches single level\nproperties.  Using a double wildcard (<code>**</code>) matches\nany deep property.</p>\n\n<h2>Listening on multiple properties and values</h2>\n\n<p>Delegate lets you listen on multiple values at once.</p>", "parents": ["can.Observe"], "plugin": "can/observe/delegate", "test": "can/observe/delegate/qunit.html", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=can/observe/delegate/delegate.js", "src": "can/observe/delegate/delegate.md", "children": []})