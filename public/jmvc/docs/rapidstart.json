c({"name": "rapidstart", "type": "page", "comment": "<p>This walks through the basics of JavaScriptMVC by building a \nsmal todo app.  Check out the [getstarted Getting Started Guide] \nfor a more in-depth overview.</p>\n\n<h2>Get JavaScriptMVC</h2>\n\n<p>[http://javascriptmvc.com/builder.html Download it] or \n[developwithgit pull it from Git].  JavaScriptMVC (JMVC) is a collection of 4 sub-projects. \nOnce you have JavaScriptMVC, you should have a folder with:</p>\n\n<pre><code>documentjs - documentation engine\nfuncunit   - testing app\njquery     - jquery and jQueryMX plugins\nsteal      - dependency management\njs         - JS command line for Linux/Mac\njs.bat     - JS command line for Windows\n</code></pre>\n\n<p><b>Notice</b>: This folder, the one that has the sub-projects, is \ncalled the [rootfolder ROOT FOLDER]</b>.</p>\n\n<h2>Get JavaScriptMVC running.</h2>\n\n<p>JMVC uses [steal steal/steal.js] for dependency \nmanagement. Steal loads scripts.  To use JavaScriptMVC's \nfeatures like [$.Controller] and [$.View],\n'steal' them like:</p>\n\n<pre><code>steal('jquery/controller','jquery/view/ejs',function(){\n   //code that uses controller and view goes here\n})\n</code></pre>\n\n<p>To use steal, you need to add the steal script to \nyour page. In the [rootfolder root folder] create a <strong>todos</strong> folder\nand empty <strong>todos.html</strong> and <strong>todos.js</strong> that look like:</p>\n\n<pre><code>ROOT\\\n    documentjs\\\n    jquery\\\n    funcunit\\\n    steal\\\n    todos\\\n      todos.js\n      todos.html\n</code></pre>\n\n<p>To load <em>steal.js</em> and <em>todos.js</em>, make <strong>todos.html</strong> look like:</p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n  &lt;ul id='todos'&gt;&lt;/ul&gt;\n  &lt;input id='editor'/&gt;\n  &lt;script type='text/javascript'\n          src='../steal/steal.js?todos/todos.js'&gt;\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Open the page in your browser.  Use a debugger like firebug to see <em>steal.js</em> and\n<em>todos.js</em> loading.</p>\n\n<h2>steal <code>steal([paths])</code></h2>\n\n<p>[steal] is used to load scripts, styles, even CoffeeScript, LESS\nand templates into your application.  </p>\n\n<p>Path are assumed to be relative to the [rootfolder root folder]. This\nmeans that the following always loads <code>jquery/class/class.js</code>\nno matter which file is calling steal:</p>\n\n<pre><code>steal('jquery/class/class.js');\n</code></pre>\n\n<p>You can load relative to the current file by adding <code>./</code> to the\nstart of your path like:</p>\n\n<pre><code>steal('./helpers.js')\n</code></pre>\n\n<p>Steal also supports css, allowing you to steal <code>todos/todos.css</code> \nlike:</p>\n\n<pre><code>steal('./todos.css')\n</code></pre>\n\n<p>Because loading paths like <code>jquery/class/class.js</code> is so \ncommon, if you do not provide an extension like <code>.js</code>, steal \nwill append the last folder name and <code>.js</code>. This makes\nthe following load <code>jquery/class/class.js</code>:</p>\n\n<pre><code>steal('jquery/class')\n</code></pre>\n\n<p>Steal is an asynchronous loader, so you can't do:</p>\n\n<pre><code>steal('jquery/class')\n$.Class\n</code></pre>\n\n<p>Instead, do:</p>\n\n<pre><code>steal('jquery/class', function(){\n  $.Class\n})\n</code></pre>\n\n<p>For this application, we will load jQueryMX's most\ncommon plugins.  Add the following to <strong>todos.js</strong>:</p>\n\n<pre><code>steal('jquery/class',\n      'jquery/model',\n      'jquery/dom/fixture',\n      'jquery/view/ejs',\n      'jquery/controller',\n      'jquery/controller/route',\n      function($){\n\n})\n</code></pre>\n\n<p>The following goes through each plugin while we build the todos app.</p>\n\n<h2>$.Class <code>$.Class([name,] [classProps,] [prototypeProps])</code></h2>\n\n<p>Constructors made with [$.Class] are used to create\nobjects with shared properties. It's used by both\n<strong>$.Controller</strong> and <strong>$.Model</strong>.</p>\n\n<p>To create a <strong>Class</strong> of your own, call <strong>$.Class</strong> with the:</p>\n\n<ul>\n<li><strong>name</strong> of the class which can be used for introspection,</li>\n<li><strong>classProperties</strong> that are attached directly to the constructor, and</li>\n<li>instance <strong>prototypeProperties</strong>.</li>\n</ul>\n\n<p><strong>$.Class</strong> sets up the prototype chain so subclasses can be further \nextended and sub-classed as far as you like:</p>\n\n<pre><code>steal('jquery/class', function(){\n\n  $.Class(\"Todo\",{\n    init : function(){},\n\n    author : function(){ ... },\n\n    coordinates : function(){ ... },\n\n    allowedToEdit: function(account) { \n     return true;\n    }\n  });\n\n  Todo('PrivateTodo',{\n    allowedToEdit: function(account) {\n      return account.owns(this);\n    }\n  })\n\n});\n</code></pre>\n\n<p><em>Brief aside on <code>super</code>.  $.Class provides a \n<code>_super</code> method to call the function of the same name higher \non the prototype chain like:</em></p>\n\n<pre><code>var SecureNote = Todo({\n  allowedToEdit: function(account) {\n    return this._super(account) &amp;&amp; \n       this.isSecure();\n  }\n})\n</code></pre>\n\n<h3>constructor / init <code>new Class(arg1, arg2)</code></h3>\n\n<p>When a class constructor is invoked, <strong>$.Class</strong> creates the instance and \ncalls [$.Class.prototype.init] with \nthe arguments passed to <code>new Class(...)</code>.</p>\n\n<pre><code>$.Class('Todo',{\n  init : function(text) {\n    this.text = text\n  },\n  read : function(){\n    console.log(this.text);\n  }\n})\n\nvar todo = new Todo(\"Hello World\");\ntodo.read()\n</code></pre>\n\n<p><em>Brief aside on <strong>init</strong>.  $.Class actually calls \n[$.Class.prototype.setup $.Class.prototype.setup] before \ninit.  <code>setup</code> can be used to change (or normalize) the arguments passed to <strong>init</strong>.</em></p>\n\n<h2>Model <code>$.Model(name, classProperties, prototypeProperties)</code></h2>\n\n<p>Models are central to any application.  They \ncontain data and logic surrounding it.  You \nextend [$.Model $.Model] with your domain specific \nmethods and $.Model provides a set of methods \nfor managing changes.</p>\n\n<p>To create a <strong>Model</strong> class, call <strong>$.Model</strong> with the:</p>\n\n<ul>\n<li><strong>name</strong> of the class,</li>\n<li><strong>classProperties</strong>, including \n[$.Model.findAll findAll],\n[$.Model.findAll findOne],\n[$.Model.create create],\n[$.Model.update update],\n[$.Model.destroy destroy] properties, and</li>\n<li>prototype instance properties.</li>\n</ul>\n\n<p>Make a Todo model in <strong>todos.js</strong> like the following:</p>\n\n<pre><code>steal('jquery/class',\n      'jquery/controller',\n      'jquery/model',\n      'jquery/view/ejs',\n      'jquery/dom/fixture',\n      function($){\n\n  $.Model('Todo',{\n    findAll : \"GET /todos\",\n    findOne : \"GET /todos/{id}\",\n    create  : \"POST /todos\",\n    update  : \"PUT /todos/{id}\",\n    destroy : \"DELETE /todos/{id}\"\n  },\n  {})\n});\n</code></pre>\n\n<p><strong>Note:</strong> Try the following commands in your browser:</p>\n\n<h3>new $.Model(attributes)</h3>\n\n<p>Create a todo instance like:</p>\n\n<pre><code>var todo = new Todo({name: \"do the dishes\"});\n</code></pre>\n\n<h3>attr <code>model.attr( name, [value] )</code></h3>\n\n<p>[$.Model.prototype.attr] reads or sets properties on model instances.</p>\n\n<pre><code>todo.attr('name') //-&gt; \"do the dishes\"\n\ntodo.attr('name', \"wash the dishes\" );\n\ntodo.attr() //-&gt; {name: \"wash the dishes\"}\n\ntodo.attr({name: \"did the dishes\"});\n</code></pre>\n\n<h3>Talking to the server</h3>\n\n<p>Model uses static [$.Model.findAll findAll],\n[$.Model.findAll findOne], [$.Model.create create],\n[$.Model.update update], and [$.Model.destroy destroy]\nmethods to create, read, update and delete \nmodel instances on the server.  </p>\n\n<p>Now you can call methods on Todo that\nmake changes on the server.  For example, \nin your console, try:</p>\n\n<pre><code>Todo.findAll({});\n</code></pre>\n\n<p>In the console, you'll see it make a request \nto <code>GET /todos</code>.</p>\n\n<p>Assuming your server does not have a <code>/todos</code> service,\nthis won't work.  That's ok, we can simulate them with\n[$.fixture].</p>\n\n<h3>$.fixture <code>$.fixture(url, fixture(original, settings, headers) )</code></h3>\n\n<p>Fixtures simulate requests to a specific \nurl.  The <code>fixture</code> function is called with:</p>\n\n<ul>\n<li><strong>original</strong> - original settings passed to $.ajax</li>\n<li><strong>settings</strong> - settings normalized by $.ajax</li>\n<li><strong>headers</strong> - request headers</li>\n</ul>\n\n<p>And, it's expected to return an array of the arguments\npassed to jQuery's ajaxTransport <code>completeCallback</code> system:</p>\n\n<pre><code>return [ status, statusText, responses, responseHeaders ];\n</code></pre>\n\n<p>This might look like:</p>\n\n<pre><code>return [ 200, \"success\", {json: []}, {} ];\n</code></pre>\n\n<p>If the array only has one item, it's assumed to be the json\ndata.  </p>\n\n<p>To simulate the todo services, add the following within the\nsteal callback:</p>\n\n<pre><code>// our list of todos\nvar TODOS = [\n    {id: 1, name: \"wake up\"},\n    {id: 2, name: \"take out trash\"},\n    {id: 3, name: \"do dishes\"}\n];\n// findAll\n$.fixture(\"GET /todos\", function(){\n  return [TODOS]\n});\n\n// findOne\n$.fixture(\"GET /todos/{id}\", function(orig){\n  return TODOS[(+orig.data.id)-1];\n})\n\n// create\nvar id= 4;\n$.fixture(\"POST /todos\", function(){\n  return {id: (id++)}\n})\n\n// update\n$.fixture(\"PUT /todos/{id}\", function(){\n  return {};\n})\n\n// destroy\n$.fixture(\"DELETE /todos/{id}\", function(){\n  return {};\n})\n</code></pre>\n\n<p>Now you can use Model's ajax methods to CRUD todos.</p>\n\n<h3>findAll <code>findAll( params, success( todos ), error() )</code></h3>\n\n<p>[$.Model.findAll findAll] retrieves multiple todos:</p>\n\n<pre><code>Todo.findAll({}, function( todos ) {\n  console.log( todos );\n})\n</code></pre>\n\n<h3>findOne <code>findOne( params, success( todo ), error() )</code></h3>\n\n<p>[$.Model.findOne findOne] retrieves a single todo:</p>\n\n<pre><code>Todo.findOne({}, function( todo ) {\n  console.log( todo );\n})\n</code></pre>\n\n<h3>save <code>todo.save( success( todo ), error() )</code></h3>\n\n<p>[$.Model::save Save] can <strong>create</strong> \nor <strong>update</strong> instances depending if the \ninstance has already been created or not.</p>\n\n<p>To <strong>create</strong> a todo on the server, create a\ntodo instance and call <strong>save</strong> like the following:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"})\ntodo.save(function(todo){\n  console.log( todo );\n})\n</code></pre>\n\n<p>To <strong>update</strong> a todo on the server, change the attributes\nand call <strong>save</strong> again like the following:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.save( function(todo){\n  console.log(\"created\", todo );\n\n  todo.attr(\"name\", \"mow my lawn\")\n  todo.save( function( todo ) {\n    console.log(\"updated\", todo );\n  })\n})\n</code></pre>\n\n<h3>destroy <code>todo.destroy( success( todo ), error() )</code></h3>\n\n<p>[$.Model.prototype.destroy Destroy] deletes a \nrecord on the server.  You can do this like:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.save( function(todo){\n  console.log(\"created\", todo );\n\n  todo.destroy( function( todo ) {\n    console.log(\"destroyed\", todo );\n  })\n})\n</code></pre>\n\n<h3>bind <code>todo.bind( event, handler(ev, todo ) )</code></h3>\n\n<p>Listening to changes in the Model is what MVC \nis about.  Model lets you [$.Model::bind bind] to changes \non an individual instance \nor [$.Model.bind all instances]. For example, you can listen to \nwhen an instance is <strong>created</strong> on the server like:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.bind('created', function(ev, todo){\n  console.log(\"created\", todo );\n})\ntodo.save()\n</code></pre>\n\n<p>You can listen to anytime an <strong>instance</strong> is created on the server by \nbinding on the model:</p>\n\n<pre><code>Todo.bind('created', function(ev, todo){\n  console.log(\"created\", todo );\n})\n</code></pre>\n\n<p>Model produces the following events on \nthe model class and instances whenever a model Ajax request completes:</p>\n\n<ul>\n<li><strong>created</strong> - an instance is created on the server</li>\n<li><strong>updated</strong> - an instance is updated on the server</li>\n<li><strong>destroyed</strong> - an instance is destroyed on the server</li>\n</ul>\n\n<h3>$.fn.model <code>$(el).model([modelInstance])</code></h3>\n\n<p>It can be helpful to label an element with a model instance\nso it can be retrieved later. [jQuery.fn.model] is used\nto get and set a model instance on an element.</p>\n\n<p>To set an instance:</p>\n\n<pre><code>var li = $('&lt;li&gt;').model( new Todo({id: 5}) )\n                  .appendTo(\"#todos\");\n</code></pre>\n\n<p>This will add <strong>'todo todo_5'</strong> to the <code>&lt;li&gt;</code>'s className. We can\nget back the model instance with:</p>\n\n<pre><code>li.model().id //-&gt; 5\n</code></pre>\n\n<h3>elements <code>todo.elements( [context] )</code></h3>\n\n<p>[$.Model::elements Elements] retrieves the elements that \nhave a model instance. A <strong>context</strong> element (or query string) can be \nprovided to limit the search to within a particular element:</p>\n\n<pre><code>todo.elements('#todos');\n</code></pre>\n\n<h2>View <code>$.View( idOrUrl, data )</code></h2>\n\n<p>[$.View $.View] is used to easily create HTML with\nJS templates. Pass it ...</p>\n\n<ul>\n<li>the <strong>id</strong> of a script tag to use as the content of the template</li>\n<li><strong>data</strong> to pass to the template</li>\n</ul>\n\n<p>... and it returns the rendered result of the template.  For\nexample, add the following to <strong>todos.html</strong>:</p>\n\n<pre><code>&lt;script type='text/ejs' id='todosEJS'&gt;\n  &lt;% for(var i = 0; i &lt; this.length; i++ ){ %&gt;\n    &lt;li&gt;&lt;%= this[i].name %&gt;&lt;/li&gt;\n  &lt;% } %&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>Render a list of todos with:</p>\n\n<pre><code> Todo.findAll( {}, function( todos ){\n     console.log( $.View( 'todosEJS', todos ) );\n });\n</code></pre>\n\n<p>$.View also takes a <strong>url</strong> for a template location.  <strong>Create</strong> \na <em>todos/todos.ejs</em> file that contains the following:</p>\n\n<pre><code>&lt;% for(var i = 0; i &lt; this.length; i++ ){ %&gt;\n  &lt;li&gt;&lt;%= this[i].name %&gt;&lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>Render this with:</p>\n\n<pre><code>Todo.findAll( {}, function( todos ){\n  console.log( $.View( 'todos.ejs', todos ) );\n});\n</code></pre>\n\n<p><strong>$.View</strong> works with any template language, such\nas JAML, jQuery-tmpl, Mustache and superpowers them with:</p>\n\n<ul>\n<li>Loading from scripts and external files </li>\n<li>using templates with jQuery <strong>modifiers</strong> like html</li>\n<li>Template caching</li>\n<li>Deferred support</li>\n<li>Bundling processed templates in production builds</li>\n</ul>\n\n<h3>Modifiers - <code>el.<i>modifier</i>( idOrUrl, data )</code></h3>\n\n<p><strong>$.View</strong> overwrites the jQuery's html modifiers\nafter, append, before, html, prepend, replaceWith, and text,\nallowing you to write:</p>\n\n<pre><code>Todo.findAll( {}, function( todos ){\n  $('#todos').html( 'todos.ejs', todos );\n});\n</code></pre>\n\n<p>To make this work, make sure <code>todos.html</code> has a <code>#todos</code> element like:</p>\n\n<pre><code>&lt;ul id='todos'&gt;&lt;/ul&gt;\n</code></pre>\n\n<h3>Deferreds</h3>\n\n<p><strong>$.Model</strong>'s ajax methods return a deffered. <strong>$.View</strong>\naccepts deferreds, making this hotness possible:</p>\n\n<pre><code>$('#todos').html('todos.ejs', Todo.findAll() )\n</code></pre>\n\n<p>This syntax will render todos.ejs with the todo instances in the AJAX request \nmade by Todo.findAll, whenever its completed.</p>\n\n<h3>Hookup <code>&lt;li &lt;%= (el)-&gt; CODE %&gt; &gt;</code></h3>\n\n<p>[$.View.hookup] lets you provide \n[http://wiki.ecmascript.org/doku.php?id=strawman:arrow<em>function</em>syntax ES5-style arrow function] \ncallbacks on elements in your template.  These callback functions\nget called after the template has been \ninserted into the DOM. You can call jQuery methods on the element like:</p>\n\n<pre><code>&lt;li &lt;%= ($el) -&gt; $el.fadeIn() %&gt; style='display:none'&gt;\n  &lt;%= this[i].name %&gt;\n&lt;/li&gt;\n</code></pre>\n\n<p>In your code, add a <strong>returning</strong>  magic tag (<code>&lt;%= %&gt;</code>) that \nmatches the <em>arrow function syntax</em>.  The argument passed to the function will\nbe the jQuery-wrapped element.  </p>\n\n<p>This lets you hookup model data to elements in EJS.  Change <strong>todos.ejs</strong> to:</p>\n\n<pre><code>&lt;% $.each(this, function(i, todo){ %&gt;\n  &lt;li &lt;%= ($el) -&gt; $el.model(todo) %&gt;&gt;\n    &lt;%= todo.name %&gt;\n    &lt;a href=\"javascript://\" class='destroy'&gt;X&lt;/a&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>Controller <code>$.Controller(name, classProps, prototypeProps)</code></h2>\n\n<p>[$.Controller] creates organized, memory-leak free, \nrapidly performing, stateful jQuery widgets. It is used to create UI controls like \ntabs, grids, and contextmenus and used to organize them \ninto higher-order business rules with [$.route]. Its serves as \nboth a traditional view and a \ntraditional controller.</p>\n\n<p>Let's make a basic todos widget that \nlists todos and lets \nus destroy them. Add the following to <strong>todos.js</strong>:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){\n    this.element.html('todos.ejs', Todo.findAll() )\n  }\n})\n</code></pre>\n\n<p>We can create this widget on the <code>#todos</code> element with:</p>\n\n<pre><code>new Todos('#todos', {});\n</code></pre>\n\n<h3>init <code>$.Controller.prototype.init(element, options)</code></h3>\n\n<p>[$.Controller::init Init] is called when a\nnew Controller instance is created.  It's called with:</p>\n\n<ul>\n<li><strong>element</strong> - The jQuery wrapped element passed to the \n              controller.  Controller accepts a jQuery element, a\n              raw HTMLElement, or a css selector.  This is\n              set as <strong>this.element</strong> on the controller instance.</li>\n<li><strong>options</strong> - The second argument passed to new Controller, extended with\n              the Controller's static <strong>defaults</strong>. This is set as \n              <strong>this.options</strong> on the controller instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new Controller()</code>.  For example:</p>\n\n<pre><code>$.Controller(\"Todos\",\n{\n  defaults : {template: 'todos.ejs'}\n},\n{\n  \"init\" : function( element , options ){\n    element.html(options.template, Todo.findAll() )\n  }\n})\n\nnew Todos( document.body.firstElementChild );\nnew Todos( $('#todos'), {template: 'specialTodos.ejs'})\n</code></pre>\n\n<h3>element <code>this.element</code></h3>\n\n<p>[$.Controller.prototype.element this.element] is the jQuery-wrapped\nelement the controller is created on. </p>\n\n<h3>options <code>this.options</code></h3>\n\n<p>[$.Controller.prototype.options this.options] is the second argument passed to \n<code>new Controller()</code> merged with the controller's static <strong>defaults</strong> property.</p>\n\n<h3>Listening to events</h3>\n\n<p>Controller automatically binds prototype methods that look\nlike event handlers.  Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){\n    this.element.html('todos.ejs', Todo.findAll() )\n  },\n  \"li click\" : function(li, event){\n    console.log(\"You clicked\", li.text() )\n\n    // let other controls know what happened\n    li.trigger('selected');\n  }\n})\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The jQuery-wrapped <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Controller uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when it's <code>&lt;a href='javascript:// class='destroy'&gt;</code> link \nis clicked:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){\n    this.element.html('todos.ejs', Todo.findAll() )\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    // get the li element that has the model\n    var li = el.closest('.todo');\n\n    // get the model\n    var todo = li.model()\n\n    //destroy it\n    todo.destroy(function(){\n      // remove the element\n      li.remove();\n    });\n  }\n})\n</code></pre>\n\n<h3>Templated Event Handlers Pt 1 <code>\"{optionName}\"</code></h3>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {destroyEvent}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n\n// create Todos with this.options.destroyEvent\nnew Todos(\"#todos\",{destroyEvent: \"mouseenter\"})\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the controller's <code>this.options</code>\nand then the <code>window</code>.  For example, we could customize it instead like:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {Events.destroy}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n\n// Events config\nEvents = {destroy: \"click\"};\n\n// Events.destroy is looked up on the window.\nnew Todos(\"#todos\")\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<h3>Templated Event Handlers Pt 2 <code>\"{objectName}\"</code></h3>\n\n<p>Controller can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is <strong>especially critical</strong>\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, that object will be \nbound to.  For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>$.Controller(\"Tooltip\",{\n  \"{window} click\" : function(el, ev){\n    // hide only if we clicked outside the tooltip\n    if(! this.element.has(ev.target ) {\n      this.element.remove();\n    }\n  }\n})\n\n// create a Tooltip\nnew Tooltip( $('&lt;div&gt;INFO&lt;/div&gt;').appendTo(el) )\n</code></pre>\n\n<p>This is convenient when needing to \nlisten to model updates.  Instead of adding a callback\nto <code>todo.destroy(cb)</code>, we should be listening to \n<strong>destroyed</strong> events.  We'll handle <strong>updated</strong> too:</p>\n\n<pre><code>$.Controller(\"Todos\",{\n  \"init\" : function( element , options ){\n    this.element.html('todos.ejs', Todo.findAll() )\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    el.closest('.todo')\n      .model()\n      .destroy();\n    ev.stopPropagation();\n  },\n  \"{Todo} destroyed\" : function(Todo, ev, destroyedTodo){\n    destroyedTodo.elements(this.element)\n                 .remove();\n  },\n  \"{Todo} updated\" : function(Todo, ev, updatedTodo){\n    updatedTodo.elements(this.element)\n               .replaceWith('todos.ejs',[updatedTodo]);\n  }\n})\n\nnew Todos(\"#todos\");\n</code></pre>\n\n<p>This is better because it removes the todo's element from the page even if another widget\ndestroyed the todo. Also, this works very well with real-time\narchitectures.</p>\n\n<h3>destroy <code>controller.destroy()</code></h3>\n\n<p>[$.Controller.prototype.destroy] unbinds a controller's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos(\"#todos\")\ntodo.destroy();\n</code></pre>\n\n<p>When a controller's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos(\"#todos\")\n$(\"#todos\").remove();\n</code></pre>\n\n<p>All event handlers bound with Controller are unbound when the controller \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and controller's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controllers within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h3>update <code>controller.update(options)</code></h3>\n\n<p>[$.Controller.prototype.update] updates a controller's \n<code>this.options</code> and rebinds all event handlers.  This is useful\nwhen you want to listen to a specific model:</p>\n\n<pre><code>$.Controller('Editor',{\n  update : function(options){\n    this._super(options)\n    this.setName();\n  },\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName : function(){\n    this.element.val(this.options.todo.name);\n  },\n  // listen for changes in the todo\n  // and update the input\n  \"{todo} updated\" : function(){\n    this.setName();\n  },\n  // when the input changes\n  // update the todo instance\n  \"change\" : function(){\n    var todo = this.options.todo\n    todo.attr('name',this.element.val() )\n    todo.save();\n  }\n});\n\nvar todo1= new Todo({id: 6, name: \"trash\"}),\n    todo2 = new Todo({id: 6, name: \"dishes\"});\n\n// create the editor;\nvar editor = new Editor(\"#editor\");\n\n// show the first todo\neditor.update({todo: todo1})\n\n// switch it to the second todo\neditor.update({todo: todo2});\n</code></pre>\n\n<p>Notice that because we are overwriting <code>update</code>, we must call <strong>_super</strong>.</p>\n\n<h2>Routing</h2>\n\n<p>[$.route] is the core of JavaScriptMVC's \nrouting functionality. It is a [jQuery.Observe] that\nupdates <code>window.location.hash</code> when it's properties change\nand updates its properties when <code>window.location.hash</code> \nchanges. It allows very sophisticated routing behavior ... too\nsophisticated for this guide. But, it also handles \nthe basics with ease.  </p>\n\n<p>Listen to routes in controller's with special \"route\" events like:</p>\n\n<pre><code>$.Controller(\"Routing\",{\n  \"route\" : function(){\n    // matches empty hash, #, or #!\n  },\n  \"todos/:id route\" : function(data){\n    // matches routes like #!todos/5\n  }\n})\n\n// create routing controller\nnew Routing(document.body);\n</code></pre>\n\n<p>The <code>route</code> methods get called back with the route <strong>data</strong>.  The \nempty <code>\"route\"</code> will be called with no data. But, <code>\"todos/:id route\"</code>\nwill be called with data like: <code>{id: 6}</code>.</p>\n\n<p>We can update the route by changing $.route's data like:</p>\n\n<pre><code>$.route.attr('id','6') // location.hash = #!todos/6\n</code></pre>\n\n<p>Or we can set the hash ourselves like</p>\n\n<pre><code>var hash = $.route.url({id: 7}) // #!todos/7\nlocation.hash = hash;\n</code></pre>\n\n<p>The following enhances the Routing controller to listen for\n<code>\".todo selected\"</code> events and change the <code>$.route</code>.  When the\n$.route changes, it retrieves the todo from the server\nand updates the editor widget.</p>\n\n<pre><code>$.Controller(\"Routing\",{\n  init : function(){\n    this.editor = new Editor(\"#editor\")\n    new Todos(\"#todos\");\n  },\n  // the index page\n  \"route\" : function(){\n     $(\"#editor\").hide();\n  },\n  \"todos/:id route\" : function(data){\n    $(\"#editor\").show();\n    Todo.findOne(data, $.proxy(function(todo){\n      this.editor.update({todo: todo});\n    }, this))\n  },\n  \".todo selected\" : function(el, ev, todo){\n    $.route.attr('id',todo.id);\n  }\n});\n\n// create routing controller\nnew Routing(document.body);\n</code></pre>\n\n<p>The <strong>Routing</strong> controller is a traditional controller. It coordinates\nbetween the <code>$.route</code>, <code>Editor</code> and <code>Todos</code>.  <code>Editor</code> and <code>Todos</code>\nare traditional views, consuming models.</p>\n\n<p>If you can understand this, you understand \neverything. Congrats!  [//tutorials/rapidstart/todos.html See it in action].</p>\n\n<h2>FuncUnit</h2>\n\n<p>JavaScriptMVC uses [FuncUnit] for testing.  FuncUnit provides an API for writing functional \ntests that simulate clicks and keypresses a user would make.</p>\n\n<p>To create a FuncUnit test:</p>\n\n<ul>\n<li>Create a test file that steals funcunit and</li>\n<li>Create a funcunit.html page that steals your test file</li>\n</ul>\n\n<p>In the <strong>todos</strong> directory, make funcunit.html and add the following HTML:</p>\n\n<pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" \n      href=\"../funcunit/qunit/qunit.css\" /&gt;\n    &lt;script type='text/javascript' \n      src='../steal/steal.js?todos/funcunit.js'&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1 id=\"qunit-header\"&gt;Todos Test Suite&lt;/h1&gt;\n    &lt;h2 id=\"qunit-banner\"&gt;&lt;/h2&gt;\n    &lt;div id=\"qunit-testrunner-toolbar\"&gt;&lt;/div&gt;\n    &lt;h2 id=\"qunit-userAgent\"&gt;&lt;/h2&gt;\n    &lt;div id=\"test-content\"&gt;&lt;/div&gt;\n    &lt;ol id=\"qunit-tests\"&gt;&lt;/ol&gt;\n    &lt;div id=\"qunit-test-area\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Now make <strong>funcunit.js</strong> and add the following:</p>\n\n<pre><code>steal('funcunit', function(){\n\n  module('todos')\n\n  test('todos test', function(){\n    ok(true, \"the test loads\");\n  })\n\n})\n</code></pre>\n\n<p>Open <strong>funcunit.html</strong> in your browser.  One test passes.</p>\n\n<h3>Writing a test</h3>\n\n<p>We tell the test to open the todos page using [FuncUnit.open S.open]:</p>\n\n<pre><code>S.open(\"//todos/todos.html\");\n</code></pre>\n\n<p>Once the page is open, we select the first todo and click it:</p>\n\n<pre><code>S(\".todo:first\").click();\n</code></pre>\n\n<p>S is a copy of jQuery's $ that adds FuncUnit's API. The editor input will \nnow appear.  Tell FuncUnit to wait for this using a [funcunit.waits wait] command:</p>\n\n<pre><code>S(\"#editor\").val(\"wake up\", \"First Todo added correctly\");\n</code></pre>\n\n<p>The second parameter is an assertion message.</p>\n\n<p>Replace the test code within the steal callback with the following:</p>\n\n<pre><code>module('todos', {\n  setup: function(){\n    S.open(\"//todos/todos.html\");\n  }\n})\n\ntest('open first todo', function(){\n  S(\".todo:first\").click();\n  S(\"#editor\").val(\"wake up\", \"First Todo added correctly\");\n})\n</code></pre>\n\n<p>Reload <strong>funcunit.html</strong>.  You'll see the page open and run the test in a separate window.</p>\n\n<p>FuncUnit has the ability to provide code coverage stats.  <a href='http://javascriptmvc.com/tutorials/rapidstart/funcunit.html?steal[instrument]=jquery%2Cfuncunit%2Csteal%2Cdocumentjs%2C*%2Ftest%2C*_test.js%2Cmxui%2C*funcunit.js'>Click</a> \nthe checkbox next to coverage to \nsee a coverage report.  81% isn't bad!  Click Todos.js to see a line by line breakdown.</p>\n\n<h3>Automation</h3>\n\n<p>To run these tests automated, run the following from the console:</p>\n\n<pre><code>./js funcunit/run selenium todos/funcunit.html\n</code></pre>\n\n<p>FuncUnit supports [funcunit.integrations integration] with CI tools \nlike [funcunit.jenkins Jenkins], build tools like [funcunit.maven maven], \nand running via the [funcunit.phantomjs PhantomJS] headless browser.</p>", "title": "Rapid Start", "parents": ["tutorials"], "order": 1, "src": "tutorials/rapidstart/rapidstart.md", "children": []})