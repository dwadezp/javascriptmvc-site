C({"name": "FuncUnit", "type": "class", "comment": "<p>FuncUnit tests web applications. Tests are written in jQuery and run in a browser. \nVia integration with [selenium Selenium] and [phantomjs PhantomJS], you can run the same tests automated.</p>\n\n<p>With FuncUnit's API, you can write test code that:</p>\n\n<ul>\n<li>[open Opens] an application page</li>\n<li>[s Queries] for elements</li>\n<li>[action Simulates] a user action</li>\n<li>[waits Waits] for a condition to be true</li>\n<li>[getters Gets] information about your page and runs assertions</li>\n</ul>\n\n<p>Then, you can:</p>\n\n<ul>\n<li>Run tests in the browser</li>\n<li>[integrations Integrate] with browser automation and build tools</li>\n</ul>\n\n<p>The [getstartedfuncunit FuncUnit Getting Started] guide is a quick walkthrough of creating and running a test.</p>\n\n<h2>Open a page</h2>\n\n<p>FuncUnit uses [QUnit's Unit test API] to set up tests.  The following runs once before every test, opening \nautocomplete.html (the app we're testing) in a separate window.</p>\n\n<pre><code class='javascript'>module(\"autosuggest\",{\n  setup: function() {\n    S.open('autosuggest.html')\n  }\n});</code></pre>\n\n<h2>Query for elements</h2>\n\n<p>FuncUnit tests are written just like jQuery.  The [S method] is a copy of jQuery, which queries for elements in \nthe application page.  Like $, FuncUnit methods are chainable on the results of S.</p>\n\n<pre><code class='javascript'>// grab the #description element, wait for it to be visible, type in it\nS(\"#description\").visible().type(\"Test Framework\")</code></pre>\n\n<h2>Simulate user actions</h2>\n\n<p>When you're testing a widget, you need to simulate the actions that a user takes.  FuncUnit uses the \n[syn] library to accurately simulate the correct low level events like mouseup and keypress for high \nlevel actions like [click] and [type].  The following shows how to simulate common user actions.</p>\n\n<p><strong>Click</strong></p>\n\n<pre><code class='javascript'>// click a button\nS('#submit_button').click()</code></pre>\n\n<p><strong>Type</strong></p>\n\n<pre><code class='javascript'>// type in an input\nS('#task_name').type(\"Learn FuncUnit\")</code></pre>\n\n<p><strong>Drag</strong></p>\n\n<pre><code class='javascript'>// drag a task item to the trash area\nS('.task').drag(\".trash\");</code></pre>\n\n<h2>Wait for page conditions</h2>\n\n<p>After a user action, your test page's event handlers run and the page is changed. \nWait commands are used to wait for some page condition before continuing.</p>\n\n<p>Waits are overloaded jQuery getter methods.  <code>S.fn.text( textVal, callback )</code> \nwaits for an element's $.fn.text to match the textVal.</p>\n\n<pre><code class='javascript'>// wait for result to show \"task complete\"\nS(\"#result\").text(\"task complete\")</code></pre>\n\n<p><strong>Visible</strong></p>\n\n<pre><code class='javascript'>// wait for first result to be visible\nS('#autocomplete_results:first-child').visible()</code></pre>\n\n<p><strong>Width</strong></p>\n\n<pre><code class='javascript'>// after clicking a menu item, wait for its width to be 200px\nS('#horizontal_menu_item').width(200)</code></pre>\n\n<p><strong>Val</strong></p>\n\n<pre><code class='javascript'>// wait for the input value\nS('#language_input').val(\"JavaScript\")</code></pre>\n\n<p><strong>Size</strong></p>\n\n<pre><code class='javascript'>// wait for number of matched elements\nS('.contact').size(5)</code></pre>\n\n<h2>Get information and run assertions</h2>\n\n<p>After simulating an action and waiting for the page to change, you often want to get information \nabout an element and run assertions.  You can use jQuery getter methods in combination with QUnit methods \nlike [ok] and [equals].</p>\n\n<p>These methods (which return synchronous results) are used in callbacks that run after a wait method completes.</p>\n\n<pre><code class='javascript'>// wait until we have some results, then call the calback\nS('.autocomplete_item').visible(function(){\n  equal( S('.autocomplete_item').size(), 5, \"there are 5 results\")\n})</code></pre>\n\n<h2>Running in browser</h2>\n\n<p>These tests can be loaded in any browser.  The app page opens in a separate window and results show up in the QUnit page.</p>\n\n<pre><code class='javascript'>test(\"JavaScript results\",function(){\n  S('input').click().type(\"JavaScript\")\n\n  // wait until we have some results\n  S('.autocomplete_item').visible(function(){\n    equal( S('.autocomplete_item').size(), 5, \"there are 5 results\")\n  })\n});</code></pre>\n\n<p><a href='funcunit/test/autosuggest/funcunit.html'>Run this test</a> (turn off your popup blocker!)</p>\n\n<h2>Integrating with automation and build tools</h2>\n\n<p>The same tests can be run via browser automation tools: Selenium, PhantomJS, and Envjs.</p>\n\n<p>These tools are driven via commandline.</p>\n\n<pre><code class='javascript'>js funcunit/run phantomjs path/to/funcunit.html</code></pre>\n\n<p>Results are reported on the commandline.  Failed tests can be made to fail your build via Maven or \nintegrated with CI tools like Jenkins.</p>", "parents": ["index"], "order": 2, "test": "test.html", "download": "http://github.com/downloads/jupiterjs/funcunit/funcunit-beta-5.zip", "src": "../funcunit/browser/waits.js", "children": ["FuncUnit.browsers", "FuncUnit.href", "FuncUnit.jmvcRoot", "FuncUnit.open", "FuncUnit.confirm", "FuncUnit.prompt", "FuncUnit.getAbsolutePath", "FuncUnit.window", "FuncUnit.prototype", "FuncUnit.prototype", "FuncUnit.prototype", "FuncUnit.add", "FuncUnit.wait", "FuncUnit.repeat", "FuncUnit.prototype", "actions", "apifuncunit", "assertions", "demos", "envjs", "features", "getstartedfuncunit", "integrations", "jenkins", "maven", "phantomjs", "s", "selenium", "waits"]})