C({"name": "todo", "type": "page", "comment": "<h2>Introduction</h2>\n\n<p>In this guide, we're going to be installing and walking through the simplest <a href=\"http://javascriptmvc.com/\">JavaScriptMVC</a>\napplication imaginable -- a TODO list manager.</p>\n\n<p>Let's get started.</p>\n\n<h2>Setup</h2>\n\n<p>First, <a href=\"https://github.com/jupiterjs/todo\">clone</a> the application from our repository at GitHub, and initialize all\nthe necessary submodules. The following commands will get you up and running:</p>\n\n<pre><code>$ git clone https://github.com/jupiterjs/todo\n$ cd todo\n$ git submodule update --init\n</code></pre>\n\n<p>This bundle now contains everything you need to run the application locally. Since we have has no server-side\nfunctionality, you should now be able to open the <code>todo/todo.html</code> file in your browser and see it in action. The\ninterface is extremely simple. Try adding a couple TODO items, and then clear them by checking the boxes and\nclicking on the \"Clear completed items\" link. That's all there is to it.</p>\n\n<h2>Structure</h2>\n\n<p>Let's take a look at the anatomy of our application:</p>\n\n<pre><code>/todo [top-level, the GitHub repo]\n  /jquery\n    /class\n    /controller\n    /model\n    /view\n    jquery.js\n    ...\n  /steal\n    /build\n    /generate\n    js\n    js.bat\n    steal.js\n    ...\n  /funcunit\n    /qunit\n      qunit.js\n      ...\n    /scripts\n    /test\n    funcunit.html\n    funcunit.js\n    qunit.html\n    ...\n  /todo\n    /scripts\n    /test\n    funcunit.html\n    qunit.html\n    todo.css\n    todo.html\n    todo.js\n    ...\n</code></pre>\n\n<p>Breaking it down:</p>\n\n<ul>\n<li>The <code>jquery</code> folder is where (unsurprisingly) the jQuery library and the JavaScriptMVC framework live. JavaScriptMVC\nconsists of powerful abstractions like [jQuery.Class $.Class], [jQuery.Model $.Model], [jQuery.Controller $.Controller],\nand [jQuery.View $.View], as well as numerous helpful jQuery plugins like <code>resize</code>, <code>destroyed</code>, <code>closest</code>, <code>cur_styles</code>,\nand <code>route</code> -- all designed to enhance your life as a JavaScript developer.</li>\n<li>The <code>steal</code> folder houses the Steal dependency management system, which is what makes it possible to keep your project\norganized during development, and compact and fast in production. Steal has two main responsibilities: As a JavaScript\nlibrary, it facilitates on-demand loading of any resources (scripts, stylesheets, templates, or even user-defined\ncontent) your application requires. As a command line utility, it takes care of bundling, compressing, and optimizing\nyour application for deployment.</li>\n<li>The FuncUnit testing framework lives in the <code>funcunit</code> folder -- think jQuery's excellent Qunit framework plus Selenium\nand headless (Env.js) support. Basically, qUnit on steroids.</li>\n<li>Lastly, our application files will live in the <code>todo</code> folder.</li>\n</ul>\n\n<h2>Architecture</h2>\n\n<p>The <a href=\"\">Model-View-Controller Pattern</a> (which we'll be referring to from here on out as MVC) is a well-established\narchitectural pattern in software engineering. Without going into too much detail, it states that there should be a clear\nseparation of concerns between the part of the system that represents the application domain (Model), the part that\nrenders the domain for user interaction (View), and the part that coordinates between the two (Controller).</p>\n\n<p>Since our application consists of only one model, one controller, and a handful of templates, we're going to just keep all\nour code in the <code>todo.js</code> and <code>todo.html</code> files. Ordinarily in a JavaScriptMVC application, to make our project easier to\nnavigate, we'd keep a single component in each file, but you'll forgive us this time for keeping it simple.</p>\n\n<h3>Dependencies</h3>\n\n<p>If you look at <code>todo.js</code> the first thing you'll notice is that all the code is wrapped in a call to the <code>steal</code> function:</p>\n\n<pre><code>steal('jquery/model/list',\n      'jquery/controller',\n      'jquery/view/ejs',\n      'jquery/lang/json',\n      './todo.css',\n      function($){\n\n...\n\n});\n</code></pre>\n\n<p>In fact, this is true of every JavaScript file in a JavaScriptMVC application. This is how we state our dependencies\nup-front, and tell the framework what libraries, plugins, stylesheets, etc. we need before we can begin. Typically,\nthe final argument to steal will be a function, which will be executed when all the other dependencies (and <em>their</em>\ndependencies, and so on...) have been loaded and executed as well. No more worrying whether you forgot any <code>&lt;script&gt;</code>\ntags, or whether you've got them in the right order!</p>\n\n<p>For our TODO app, we can see that our script requires the [jQuery.Model.List $.Model.List] class (which itself requires\nthe [jQuery.Model $.Model] class, the [jQuery.Controller $.Controller] class, a jQuery JSON helper, and our application's\nstylesheet.</p>\n\n<h3>Model</h3>\n\n<p>All models in JavaScriptMVC extend the [jQuery.Model $.Model] class, like so:</p>\n\n<pre><code>$.Model('Todo', { /* static properties */ }, { /* instance/prototype properties */ });\n</code></pre>\n\n<p>(If you need a quick refresher on how to use JVMC's classes, see [jQuery.Class $.Class].)</p>\n\n<p>Since we want our TODO list manager to function without a server (who said application domains require servers, anyway?),\nwe need some form of persistence in the browser. Sure, cookies are nice, but we're looking to the future, man -- so lets\ntake advantage of HTML5's LocalStorage!</p>\n\n<pre><code>$.Model('Todo',{\n  /**\n   * Gets JSON data from localStorage.  Any changes that \n   * get made in cb get written back to localStorage.\n   * \n   * This is unimportant for understanding JavaScriptMVC!\n   */\n  localStore: function(cb){\n    var name = this.shortName,\n      data = $.evalJSON( window.localStorage[name] || (window.localStorage[name] = \"{}\") ),\n      res = cb.call(this, data);\n    if(res !== false){\n      window.localStorage[name] = $.toJSON(data);\n    }\n  },\n</code></pre>\n\n<p>Here, we've defined our <code>Todo</code> class with a static (shared across all instances), state-of-the-art HTML5 storage system\n(don't worry too much about what this does). The <code>localStore</code> method accepts a function which it assumes is a callback.\nSince HTML5 local storage is a JSON-store, that means we'll receive an array of <code>Todo</code> <em>properties</em> when our callback\nfires. All of our CRUD operations will use this helper in order to persist <code>Todo</code> items in the system.</p>\n\n<pre><code>  findAll: function(params, success){\n    this.localStore(function(todos){\n      var instances = [];\n      for(var id in todos){\n        instances.push( new this( todos[id]) )\n      }\n      success &amp;&amp; success(instances)\n    })\n  },\n</code></pre>\n\n<p>Given our <code>localStorage</code> helper, we've now defined a finder method that returns all <code>Todos</code> that the application knows\nabout. Inside the callback, we just iterate over those objects, and create <code>Todo</code>s out of them. Simple!</p>\n\n<blockquote>\n  <p><em>Tip</em>: Don't let that <code>new this( ... )</code> trip you up. Since we're in the static (class) context, <code>this</code> simply refers to the\n  <code>Todo</code> class itself. Writing <code>new Todo( ... )</code> would have the same effect, but this way our code won't break if we ever\n  decide to rename the class to something else.</p>\n</blockquote>\n\n<p>The rest of the CRUD methods are similar enough.</p>\n\n<h3>Lists</h3>\n\n<p>One of the truly great features of JavaScriptMVC is the [jQuery.Model.List $.Model.List]. A Model.List gives us a way\nto manage a collection of models as an aggregate, and (the cool part) be able to respond to and trigger events at the\ncollection level. For our present purposes, we'd like to have a list of <code>Todo</code> items that can tell us which ones have\nbeen marked as completed:</p>\n\n<pre><code>$.Model.List('Todo.List',{\n  /**\n   * Return a new Todo.List of only complete items\n   */\n  completed : function(){\n    return this.grep(function(item){\n      return item.complete === true;\n    })\n  }\n});\n</code></pre>\n\n<p>Keep an eye out for this below when we're implementing the controller.</p>\n\n<h2>Controller</h2>\n\n<p>Unlike models, controllers and views are inherently tied to the application's user interface, so before we dive into the\nJavaScript code, let's take a quick look at the basic HTML structure of the application:</p>\n\n<pre><code>&lt;div id='todos'&gt;\n  &lt;h1&gt;Todos&lt;/h1&gt;\n  &lt;input type='text' class='create' /&gt; \n  &lt;ul id='list'&gt;\n  &lt;/ul&gt;\n  &lt;div id='todo-stats'&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Not much to it, is there! We can see that we have one wrapper element -- make a note of that, because that's the element\nwe're eventually going to attach the controller to.</p>\n\n<p>Inside that wrapper, we have the following items:</p>\n\n<ul>\n<li>A title (\"Todos\")</li>\n<li>A text box where we're going to add new Todo items</li>\n<li>A list where we'll see all current Todo items</li>\n<li>Another container for \"stats\" where we'll show a count of what the user has selected, and give them a way to \"finish\"\nitems</li>\n</ul>\n\n<p>With that document structure in mind, let's look at the code:</p>\n\n<pre><code>$.Controller('Todos',{\n\n  // sets up the widget\n  init : function(){\n\n    // empties the create input element\n    this.find(\".create\").val(\"\")[0].focus();\n\n    // fills this list of items (creates add events on the list)\n    this.options.list.findAll();\n  },\n</code></pre>\n\n<p>The <code>init</code> method is what will be called when we initialize the controller. The <code>find</code> method here is like <code>jQuery.find</code>\nin that it searches for a selector underneath an element -- in this case, the element being managed by the controller. We\nwant to look up the <code>.create</code> selector (the text box we saw above), set its text value to the empty string, and then\ncause the browser to \"focus,\" or place the mouse cursor in the box.</p>\n\n<p>The second statement is the interesting one: because <code>this.options</code> always refers to the properties that were passed in to\nthe controller upon initialization, we can see here that we are expecting to be initialized with a list -- a <code>Todo.List</code>\nto be exact. Another great thing about [jQuery.Model.List $.Model.List]s is that they steal most of their default behavior\nfrom the underlying model, so basically we've gotten a free implementation of <code>findAll</code>, simply because <code>Todo</code> has a\n<code>findAll</code> method. Pretty nice!</p>\n\n<p>We also saw that [jQuery.Model.List $.Model.List]s trigger their own events which we can listen on in. Keep an eye out\nfor that below.</p>", "title": "Todo", "parents": ["examples"], "order": 2, "src": "tutorials/todo.md", "children": []})