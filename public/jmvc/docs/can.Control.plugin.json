c({"name": "can.Control.plugin", "type": "page", "comment": "<p>The can.Control plugin extension creates a plugin for the control on the \njQuery prototype, using the control's [can.Construct.fullName fullName] or\na static <code>pluginName</code> attribute. For example, given the following control:</p>\n\n<pre><code>var Tabs = can.Control({\n    pluginName: 'tabs'\n}, {\n    init: function( element, options, arg1 ) {},\n    update: function( options ) {}\n});\n</code></pre>\n\n<p>Using jQuery, create the control directly on a jQuery collection like:</p>\n\n<pre><code>$( '.tabs' ).tabs();\n</code></pre>\n\n<p><strong>Note:</strong> This plugin only supports jQuery.</p>\n\n<h2>Plugin Name</h2>\n\n<p>Setting the static <code>pluginName</code> property allows you to set the can plugin helper name:</p>\n\n<pre><code>var Filler = can.Control({\n    pluginName: \"fillWith\"\n}, {});\n\n$( '#foo' ).fillWith();\n</code></pre>\n\n<p>If you don't provide a plugin name, the control falls back to the\n[can.Construct.fullName fullName] attribute:</p>\n\n<pre><code>can.Control('Ui.Layout.FillWith', {}, {});\n$( '#foo' ).ui_layout_fill_with();\n</code></pre>\n\n<h2>Updating</h2>\n\n<p>Update extends [can.Control.prototype.options options] \nwith the <code>options</code> argument and rebinds all events.  It \nre-configures the control.</p>\n\n<p>For example, the following control wraps a recipe form. When the form\nis submitted, it creates the recipe on the server.  When the recipe\nis <code>created</code>, it resets the form with a new instance.</p>\n\n<pre><code>var Creator = can.Control({\n    '{recipe} created': function() {\n        this.update({ recipe : new Recipe() });\n        this.element[0].reset();\n        this.find( '[type=submit]' ).val( 'Create Recipe' );\n    },\n    'submit': function( el, ev ) {\n        ev.preventDefault();\n        var recipe = this.options.recipe;\n        recipe.attrs( this.element.formParams() );\n        this.find( '[type=submit]' ).val( 'Saving...' );\n        recipe.save();\n    }\n});\n\n$( '#createRecipes' ).creator({ recipe : new Recipe() });\n</code></pre>\n\n<p><code>update</code> is called if a Control's plugin helper is called with the plugin options on an element\nthat already has a control instance of the same type. To implement your\nown update method, make sure to call the old one either using the [can.Contruct.super] plugin or\nby calling <code>can.Control.prototype.update.apply(this, arguments);</code>.\nFor example, to change the content of the control element every time the options change:</p>\n\n<pre><code>var Plugin = can.Control({\n    pluginName: 'myPlugin'\n}, {\n    init : function(el, options) {\n        this.updateCount = 0;\n        this.update({\n            text : 'Initialized'\n        });\n    },\n\n    update : function(options) {\n        // Call the old update. Use this._super when using can/construct/super\n        can.Control.prototype.update.call(this, options);\n        this.element.html( this.options.text + ' ' + (++this.updateCount) + ' times' );\n    }\n});\n\n$( '#control' ).myPlugin();\n$( '#control' ).html();\n// Initialized. Updated 1 times\n$( '#control' ).myPlugin({ text : 'Calling update. Updated' });\n$( '#control' ).html();\n// Calling update. Updated 2 times\n</code></pre>\n\n<h2>Calling methods</h2>\n\n<p>There are a few different ways to invoke methods on a controller instance after\nit's created. Given the following Control:</p>\n\n<pre><code>var MyTodo = can.Control({\n    create: function( name, task ) {\n        this.element.append( name + ' ' + task );\n    }\n});\n</code></pre>\n\n<p>If there is only a single Control instance attached to a DOM element, you can\nsimply invoke the method directly on the instance like:</p>\n\n<pre><code>var todoControl = new MyTodo( '#my_todo ');\ntodoControl.create( 'Austin', 'Sweep garage' );\n</code></pre>\n\n<p>After a Control has been initialized on a jQuery collection, a method can be\ncalled over the entire collection by invoking the plugin with the method\nname parameter, along with any additional arguments you want to pass:</p>\n\n<pre><code>$( '.my_todo' ).my_todo( 'create', 'Austin', 'Sweep garage' );\n</code></pre>\n\n<p>Keep in mind that this approach follows the jQuery plugin convention and returns\na jQuery object for chaining, not the method's return value.</p>\n\n<p>For more information on fetching controller instances on DOM elements see \nthe <strong>Access</strong> section.</p>\n\n<h2>Access</h2>\n\n<p>When the widget is initialized, the plugin control creates an association \nof Control instance(s) to the DOM element it was initialized on using \n[can.data] method.</p>\n\n<h3>Controller</h3>\n\n<p>The <code>controller</code> method allows you to get a Control instance for the element. <br />\nWith no arguments, returns the first one found, otherwise the first Control\ninstance with this class type will be returned.</p>\n\n<pre><code>&lt;div id=\"widget\" class=\"my_widget\"&gt;\n\n$('#widget').controller() // will return: MyWidget\n</code></pre>\n\n<h3>Controllers</h3>\n\n<p>The <code>controllers</code> method allows you to get all the Controls attached to the element.\nFor example, we can fetch both the <em>MyWidget</em> and the <em>MyClock</em> instance \nbelow by calling <code>controllers</code> on the DOM element.</p>\n\n<pre><code>&lt;div id=\"widget\" class=\"my_widget my_clock\"&gt;\n\n$('#widget').controllers() // will return: [ MyWidget, MyClock ]\n</code></pre>", "parents": ["can.Control"], "plugin": "can/control/plugin", "test": "can/control/plugin/qunit.html", "download": "http://donejs.com/can/dist/can.control.plugin.js", "src": "can/control/plugin/plugin.md", "children": []})