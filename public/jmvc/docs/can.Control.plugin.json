c({"name": "can.Control.plugin", "type": "page", "comment": "<p>The can.Control plugin extension creates a plugin for the control in the \njQuery NodeList using the control's [can.Construct.fullName fullName] or\na static pluginName attribute. For example, if you create the following control:</p>\n\n<pre><code>var Tabs = can.Control({\n    pluginName : 'tabs'\n},{\n    init : function(element, options, arg1){ },\n    update : function(options) {}\n})\n</code></pre>\n\n<p>With jQuery, you can create the control direct on a jQuery collection like:</p>\n\n<pre><code>$(\".tabs\").tabs();\n</code></pre>\n\n<p><strong>Note:</strong> This plugin only supports jQuery.</p>\n\n<h2>Plugin Name</h2>\n\n<p>Setting the static <code>pluginName</code> property allows you to set the can plugin helper name:</p>\n\n<pre><code>var Filler = can.Control({\n    pluginName: \"fillWith\"\n},{});\n\n$(\"#foo\").fillWith();\n</code></pre>\n\n<p>If you don't provide a plugin name, the control falls back to the\n[can.Construct.fullName fullName] attribute:</p>\n\n<pre><code>can.Control('Ui.Layout.FillWith', {}, {});\n$(\"#foo\").ui_layout_fill_with();\n</code></pre>\n\n<h2>Updating</h2>\n\n<p>Update extends [can.Control.prototype.options options] \nwith the <code>options</code> argument and rebinds all events.  It \nre-configures the control.</p>\n\n<p>For example, the following control wraps a recipe form. When the form\nis submitted, it creates the recipe on the server.  When the recipe\nis <code>created</code>, it resets the form with a new instance.</p>\n\n<pre><code>var Creator = can.Control({\n    \"{recipe} created\" : function(){\n        this.update({recipe : new Recipe()});\n        this.element[0].reset();\n        this.find(\"[type=submit]\").val(\"Create Recipe\")\n    },\n    \"submit\" : function(el, ev){\n        ev.preventDefault();\n        var recipe = this.options.recipe;\n        recipe.attrs( this.element.formParams() );\n        this.find(\"[type=submit]\").val(\"Saving...\")\n        recipe.save();\n    }\n});\n\n$('#createRecipes').creator({ recipe : new Recipe() })\n</code></pre>\n\n<p><em>Update</em> is called if a control's plugin helper is called with the plugin options on an element\nthat already has a control instance of the same type. If you want to implement your\nown update method make sure to call the old one either using the [can.Contruct.super] plugin or\nby calling <code>can.Control.prototype.update.apply(this, arguments);</code>.\nFor example, you can change the content of the control element every time the options change:</p>\n\n<pre><code>var Plugin = can.Control({\n    pluginName: 'myPlugin'\n}, {\n    init : function(el, options) {\n        this.updateCount = 0;\n        this.update({\n            text : 'Initialized'\n        });\n    },\n\n    update : function(options) {\n        // Call the old update. Use this._super when using can/construct/super\n        can.Control.prototype.update.call(this, options);\n        this.element.html(this.options.text + ' ' + (++this.updateCount) + ' times');\n    }\n});\n\n$('#control').myPlugin();\n$('#control').html();\n// Initialized. Updated 1 times\n$('#control').myPlugin({ text : 'Calling update. Updated' });\n$('#control').html();\n// Calling update. Updated 2 times\n</code></pre>\n\n<h2>Calling methods</h2>\n\n<p>You can invoke methods on a controller instance after its created through a few\ndifferent approaches.  </p>\n\n<p>Once a controller is initialized on a DOM element, you can invoke a method by calling\nthe plugin with the method name followed by the parameters for that method.</p>\n\n<pre><code>var MyTodo = can.Control({\n    pluginName : 'my_toto'\n}, {\n    create: function(name, task){\n        this.element.append(name + \" \" + task)\n    }\n});\n\n$('.my_todo').my_todo(\"create\", 'Austin', 'Sweep garage');\n</code></pre>\n\n<p>Keep in mind that this approach follows the jQuery plugin convention and returns a jQuery object,\nnot the methods return value. You can also retrieve the control instance and invoke the method directly.\nFor more information on fetching controller instances on DOM elements see \nthe <strong>Access</strong> section.</p>\n\n<h2>Access</h2>\n\n<p>When the widget is initialized, the plugin control creates an association \nof controller instance(s) with the DOM element it was initialized on using \n[can.data] method.</p>\n\n<h3>Controller</h3>\n\n<p>The <code>controller</code> method allows you to get a controller instance for the element. <br />\nWith no arguments, returns the first one found otherwise the first controller \ninstance with this class type will be returned.</p>\n\n<pre><code>&lt;div id=\"widget\" class=\"my_widget\"&gt;\n\n$('#widget').controller() //- will return: MyWidget\n</code></pre>\n\n<h3>Controllers</h3>\n\n<p>The <code>controllers</code> method allows you to get all the controllers attached to the element.\nFor example, we can fetch both the <em>MyWidget</em> and the <em>MyClock</em> instance \nbelow by calling <code>controllers</code> on the DOM element.</p>\n\n<pre><code>&lt;div id=\"widget\" class=\"my_widget my_clock\"&gt;\n\n$('#widget').controllers() //- will return: [ MyWidget, MyClock ]\n</code></pre>", "parents": ["can.Control"], "plugin": "can/control/plugin", "test": "can/control/plugin/qunit.html", "download": "http://donejs.com/can/dist/can.control.plugin.js", "src": "can/control/plugin/plugin.md", "children": []})