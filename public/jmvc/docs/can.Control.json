c({"name": "can.Control", "type": "class", "comment": "<p>jQuery.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls.  Use it to create UI controls like tabs, grids, and contextmenus \nand used to organize them into higher-order business rules with\n can.route. It can serve as a traditional view and a traditional controller.</p>\n\n<p>The following examples make a basic todos widget that lists \ntodos and lets us destroy them. Create a control constructor \nfunction of your own by extending can.Control.</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ) {\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html('todos.ejs', todos )\n    })\n  }\n})\n</code></pre>\n\n<p>Create an instance of the Todos control the #todos element with:</p>\n\n<pre><code>var todosControl = new Todos('#todos', {});\n</code></pre>\n\n<p>todos.ejs looks like:</p>\n\n<pre><code>&lt;% list(todos, function(todo){ %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data(\"todo\", todo) %&gt; &gt;\n    &lt;%= todo.attr('name') %&gt;\n    &lt;a href='javascript:// class='destroy'&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h3>init <code>can.Control.prototype.init(element, options)</code></h3>\n\n<p><code>init</code> is called when a\nnew can.Control instance is created.  It's called with:</p>\n\n<ul>\n<li><strong>element</strong> - The wrapped element passed to the \n            control. Control accepts a\n            raw HTMLElement, a css selector, or a NodeList.  This is\n            set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n            the can.Control's static <strong>defaults</strong>. This is set as \n            <strong>this.options</strong> on the control instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new can.Control()</code>.  For example:</p>\n\n<pre><code>var Todos = can.Control({\n  defaults : {view: 'todos.ejs'}\n},{\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html(self.options.view, todos )\n    })\n  }\n})\n\n// create a Todos with default options\nnew Todos( document.body.firstElementChild );\n\n// overwrite the template option\nnew Todos( $('#todos'), {template: 'specialTodos.ejs'})\n</code></pre>\n\n<h3>element <code>this.element</code></h3>\n\n<p>[can.Control::element] is the \na nodelist of a single element, the element the control is created on. </p>\n\n<pre><code>var todosControl = new Todos( document.body.firstElementChild );\ntodosControl.element[0] //-&gt; document.body.firstElementChild\n</code></pre>\n\n<p>Each library wraps the element differently.  If you are using jQuery, the element is wrapped with <code>jQuery( element )</code>.</p>\n\n<h3>options <code>this.options</code></h3>\n\n<p>[can.Control::options] is the second argument passed to \n<code>new can.Control()</code> merged with the control's static <strong>defaults</strong> property.</p>\n\n<h3>Listening to events</h3>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers.  Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li, event){\n    console.log(\"You clicked\", li.text() )\n\n    // let other controls know what happened\n    li.trigger('selected');\n  }\n})\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The library-wrapped <strong>element</strong> that was clicked.</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when it's <code>&lt;a href='javascript:// class='destroy'&gt;</code> link \nis clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    // get the li element that has todo data\n    var li = el.closest('li');\n\n    // get the model\n    var todo = li.data('todo')\n\n    //destroy it\n    todo.destroy();\n  }\n})\n</code></pre>\n\n<p>When the todo is destroyed, EJS's live binding will remove it's LI automatically.</p>\n\n<h3>Templated Event Handlers Pt 1 <code>\"{optionName}\"</code></h3>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {destroyEvent}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n\n// create Todos with this.options.destroyEvent\nnew Todos(\"#todos\",{destroyEvent: \"mouseenter\"})\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the control's <code>this.options</code>\nand then the <code>window</code>.  For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {Events.destroy}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n\n// Events config\nEvents = {destroy: \"click\"};\n\n// Events.destroy is looked up on the window.\nnew Todos(\"#todos\")\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<h3>Templated Event Handlers Pt 2 <code>\"{objectName}\"</code></h3>\n\n<p>Control can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is _critical\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, that object will be \nbound to.  For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  \"{window} click\" : function(el, ev){\n    // hide only if we clicked outside the tooltip\n    if(! this.element.has(ev.target ) {\n      this.element.remove();\n    }\n  }\n})\n\n// create a Tooltip\nnew Tooltip( $('&lt;div&gt;INFO&lt;/div&gt;').appendTo(el) )\n</code></pre>\n\n<p>This is convenient when needing to \nlisten to model changes.  If EJS was not taking care of\nremoving <code>&lt;li&gt;</code>s after their model is destroyed, we\ncould implement it in <code>Todos</code> like:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.todosList = todos;\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    // get the li element that has todo data\n    var li = el.closest('li');\n\n    // get the model\n    var todo = li.data('todo')\n\n    //destroy it\n    todo.destroy();\n  },\n  \"{Todo} destroyed\" : funtion(Todo, ev, todoDestroyed) {\n    // find where the element\n    var index = this.todosList.indexOf(todoDestroyed)\n    this.element.children(\":nth-child(\"+(index+1)+\")\")\n        .remove()\n  }\n})\n\nnew Todos(\"#todos\");\n</code></pre>\n\n<h3>destroy <code>control.destroy()</code></h3>\n\n<p>[can.Control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos(\"#todos\")\ntodo.destroy();\n</code></pre>\n\n<p>When a control's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos(\"#todos\")\n$(\"#todos\").remove();\n</code></pre>\n\n<p>All event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h3>on <code>control.on()</code></h3>\n\n<p>[can.Control::on] rebinds a control's event handlers.  This is useful when you want\nto listen to a specific model and change it:</p>\n\n<pre><code>var Editor = can.Control({\n  todo : function(todo){\n    this.options.todo = todo;\n    this.on();\n    this.setName();\n  },\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName : function(){\n    this.element.val(this.options.todo.name);\n  },\n  // listen for changes in the todo\n  // and update the input\n  \"{todo} updated\" : function(){\n    this.setName();\n  },\n  // when the input changes\n  // update the todo instance\n  \"change\" : function(){\n    var todo = this.options.todo\n    todo.attr('name',this.element.val() )\n    todo.save();\n  }\n});\n\nvar todo1 = new Todo({id: 6, name: \"trash\"}),\n    todo2 = new Todo({id: 6, name: \"dishes\"});\n\n// create the editor;\nvar editor = new Editor(\"#editor\");\n\n// show the first todo\neditor.todo( todo1 )\n\n// switch it to the second todo\neditor.todo( todo2 );\n</code></pre>\n\n<h2>Tabs Example</h2>\n\n<div class='demo_wrapper' data-demo-src='can/control/control.html'></div>", "parents": ["index"], "plugin": "can/control", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/control/control.js", "test": "can/control/qunit.html", "inherits": "can.Construct", "description": "jQuery widget factory.", "src": "can/control/control.md", "children": ["can.Control.plugin", "can.Control.route", "can.Control.view"]})