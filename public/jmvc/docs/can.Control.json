c({"name": "can.Control", "type": "class", "comment": "<p>jQuery.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls.  Use it to create UI controls like tabs, grids, and contextmenus \nand used to organize them into higher-order business rules with\n can.route. It can serve as a traditional view and a traditional controller.</p>\n\n<p>The following examples make a basic todos widget that lists \ntodos and lets us destroy them. Create a control constructor \nfunction of your own by extending can.Control.</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ) {\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html('todos.ejs', todos )\n    })\n  }\n})\n</code></pre>\n\n<p>Create an instance of the Todos control the #todos element with:</p>\n\n<pre><code>var todosControl = new Todos('#todos', {});\n</code></pre>\n\n<p>todos.ejs looks like:</p>\n\n<pre><code>&lt;% list(todos, function(todo){ %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data(\"todo\", todo) %&gt; &gt;\n    &lt;%= todo.attr('name') %&gt;\n    &lt;a href='javascript:// class='destroy'&gt;\n  &lt;/li&gt;\n</code></pre>\n\n   <% }) %>\n\n<p>This means it is used to\ncreate things like tabs, grids, and contextmenus as well as \norganizing them into higher-order business rules.</p>\n\n<p>Controls make your code deterministic, reusable, organized and can tear themselves \ndown auto-magically. Read about [http://jupiterjs.com/news/writing-the-perfect-jquery-plugin \nthe theory behind control] and \na [http://jupiterjs.com/news/organize-jquery-widgets-with-jquery-control walkthrough of its features]\non Jupiter's blog. [mvc.control Get Started with jQueryMX] also has a great walkthrough.</p>\n\n<p>Control inherits from [can.Construct can.Construct] and makes heavy use of \n[http://api.jquery.com/delegate/ event delegation]. Make sure \nyou understand these concepts before using it.</p>\n\n<h2>Basic Example</h2>\n\n<p>Instead of</p>\n\n<pre><code>$(function(){\n  $('#tabs').click(someCallbackFunction1)\n  $('#tabs .tab').click(someCallbackFunction2)\n  $('#tabs .delete click').click(someCallbackFunction3)\n});\n</code></pre>\n\n<p>do this</p>\n\n<pre><code>can.Control('Tabs',{\n  click: function() {...},\n  '.tab click' : function() {...},\n  '.delete click' : function() {...}\n})\n$('#tabs').tabs();\n</code></pre>\n\n<h2>Tabs Example</h2>\n\n<div class='demo_wrapper' data-demo-src='jquery/control/control.html'></div>\n\n<h2>Using Control</h2>\n\n<p>Control helps you build and organize jQuery plugins.  It can be used\nto build simple widgets, like a slider, or organize multiple\nwidgets into something greater.</p>\n\n<p>To understand how to use Control, you need to understand \nthe typical lifecycle of a jQuery widget and how that maps to\ncontrol's functionality:</p>\n\n<h3>A control class is created.</h3>\n\n<pre><code>can.Control(\"MyWidget\",\n{\n  defaults :  {\n    message : \"Remove Me\"\n  }\n},\n{\n  init : function(rawEl, rawOptions){ \n    this.element.append(\n       \"&lt;div&gt;\"+this.options.message+\"&lt;/div&gt;\"\n      );\n  },\n  \"div click\" : function(div, ev){ \n    div.remove();\n  }  \n}) \n</code></pre>\n\n<p>This creates a <code>$.fn.my_widget</code> jQuery helper function\nthat can be used to create a new control instance on an element. Find\nmore information [jquery.control.plugin  here] about the plugin gets created \nand the rules around its name.</p>\n\n<h3>An instance of control is created on an element</h3>\n\n<pre><code>$('.thing').my_widget(options) // calls new MyWidget(el, options)\n</code></pre>\n\n<p>This calls <code>new MyWidget(el, options)</code> on \neach <code>'.thing'</code> element.  </p>\n\n<p>When a new [can.Construct Class] instance is created, it calls the class's\nprototype setup and init methods. Control's [jQuery.Control.prototype.setup setup]\nmethod:</p>\n\n<ul>\n<li>Sets [jQuery.Control.prototype.element this.element] and adds the control's name to element's className.</li>\n<li>Merges passed in options with defaults object and sets it as [jQuery.Control.prototype.options this.options]</li>\n<li>Saves a reference to the control in <code>$.data</code>.</li>\n<li>[jquery.control.listening Binds all event handler methods].</li>\n</ul>\n\n<h3>The control responds to events</h3>\n\n<p>Typically, Control event handlers are automatically bound.  However, there are\nmultiple ways to [jquery.control.listening listen to events] with a control.</p>\n\n<p>Once an event does happen, the callback function is always called with 'this' \nreferencing the control instance.  This makes it easy to use helper functions and\nsave state on the control.</p>\n\n<h3>The widget is destroyed</h3>\n\n<p>If the element is removed from the page, the \ncontrol's [jQuery.Control.prototype.destroy] method is called.\nThis is a great place to put any additional teardown functionality.</p>\n\n<p>You can also teardown a control programatically like:</p>\n\n<pre><code>$('.thing').my_widget('destroy');\n</code></pre>\n\n<h2>Todos Example</h2>\n\n<p>Lets look at a very basic example - \na list of todos and a button you want to click to create a new todo.\nYour HTML might look like:</p>\n\n<pre><code class='html'>&lt;div id='todos'>\n &lt;ol>\n   &lt;li class=\"todo\">Laundry&lt;/li>\n   &lt;li class=\"todo\">Dishes&lt;/li>\n   &lt;li class=\"todo\">Walk Dog&lt;/li>\n &lt;/ol>\n &lt;a class=\"create\">Create&lt;/a>\n&lt;/div></code></pre>\n\n<p>To add a mousover effect and create todos, your control might look like:</p>\n\n<pre><code>can.Control('Todos',{\n  \".todo mouseover\" : function( el, ev ) {\n    el.css(\"backgroundColor\",\"red\")\n  },\n  \".todo mouseout\" : function( el, ev ) {\n    el.css(\"backgroundColor\",\"\")\n  },\n  \".create click\" : function() {\n    this.find(\"ol\").append(\"&amp;lt;li class='todo'&gt;New Todo&amp;lt;/li&gt;\"); \n  }\n})\n</code></pre>\n\n<p>Now that you've created the control class, you've must attach the event handlers on the '#todos' div by\ncreating [jQuery.Control.prototype.setup|a new control instance].  There are 2 ways of doing this.</p>\n\n<pre><code class='javascript'>//1. Create a new control directly:\nnew Todos($('#todos'));\n//2. Use jQuery function\n$('#todos').todos();</code></pre>\n\n<h2>Control Initialization</h2>\n\n<p>It can be extremely useful to add an init method with \nsetup functionality for your widget.</p>\n\n<p>In the following example, I create a control that when created, will put a message as the content of the element:</p>\n\n<pre><code>$.Control(\"SpecialControl\",\n{\n  init: function( el, message ) {\n    this.element.html(message)\n  }\n})\n$(\".special\").special(\"Hello World\")\n</code></pre>\n\n<h2>Removing Controls</h2>\n\n<p>Control removal is built into jQuery.  So to remove a control, you just have to remove its element:</p>\n\n<pre><code class='javascript'>$(\".special_control\").remove()\n$(\"#containsControls\").html(\"\")</code></pre>\n\n<p>It's important to note that if you use raw DOM methods (<code>innerHTML, removeChild</code>), the controls won't be destroyed.</p>\n\n<p>If you just want to remove control functionality, call destroy on the control instance:</p>\n\n<pre><code class='javascript'>$(\".special_control\").control().destroy()</code></pre>\n\n<h2>Accessing Controls</h2>\n\n<p>Often you need to get a reference to a control, there are a few ways of doing that.  For the \nfollowing example, we assume there are 2 elements with <code>className=\"special\"</code>.</p>\n\n<pre><code class='javascript'>//creates 2 foo controls\n$(\".special\").foo()\n\n//creates 2 bar controls\n$(\".special\").bar()\n\n//gets all controls on all elements:\n$(\".special\").controls() //-> [foo, bar, foo, bar]\n\n//gets only foo controls\n$(\".special\").controls(FooControl) //-> [foo, foo]\n\n//gets all bar controls\n$(\".special\").controls(BarControl) //-> [bar, bar]\n\n//gets first control\n$(\".special\").control() //-> foo\n\n//gets foo control via data\n$(\".special\").data(\"controls\")[\"FooControl\"] //-> foo</code></pre>\n\n<h2>Calling methods on Controls</h2>\n\n<p>Once you have a reference to an element, you can call methods on it.  However, Control has\na few shortcuts:</p>\n\n<pre><code class='javascript'>//creates foo control\n$(\".special\").foo({name: \"value\"})\n\n//calls FooControl.prototype.update\n$(\".special\").foo({name: \"value2\"})\n\n//calls FooControl.prototype.bar\n$(\".special\").foo(\"bar\",\"something I want to pass\")</code></pre>\n\n<p>These methods let you call one control from another control.</p>\n\n<h1>can.Control</h1>\n\n<ul>\n<li>Organize Event Handlers</li>\n<li>Keep your control from leaking</li>\n</ul>\n\n<h2>Creating a Control constructor</h2>\n\n<h2>Creating a Control instance</h2>\n\n<h2>setup</h2>\n\n<h2>init</h2>\n\n<h2>update - rebinds</h2>\n\n<h2>destroy - removes event handlers</h2>\n\n<h2>examples</h2>\n\n<ul>\n<li>creating a tabs widget</li>\n<li>creating </li>\n</ul>\n\n<h2>listening to events ...</h2>\n\n<h2>Listening to events</h2>\n\n<p>Controller automatically binds prototype methods that look like event \nhandlers. Listen to <strong>clicks</strong> on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li, event){\n    console.log(\"You clicked\", li.text() )\n\n    // let other controls know what happened\n    li.trigger('selected');\n  }\n})\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The element that was clicked, wrapped with the library's NodeList.</li>\n<li>The event data.</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind event handlers.</p>\n\n<p>To destroy a todo when it’s <code>&lt;a href='javascript:// class='destroy'&gt;</code> link is clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    // get the li element that has todo data\n    var li = el.closest('li');\n\n    // get the model\n    var todo = li.data('todo')\n\n    //destroy it\n    todo.destroy();\n  }\n})\n</code></pre>\n\n<p>When the todo is destroyed, EJS’s live binding will remove it’s <code>&lt;li&gt;</code> automatically.</p>\n\n<h2>Templated Event Handlers Pt 1 \"{optionName}\"</h2>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in the event \nhandler name. The following allows customization of the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {destroyEvent}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n</code></pre>\n\n<p>// create Todos with this.options.destroyEvent\nnew Todos(\"#todos\",{destroyEvent: \"mouseenter\"})\nValues inside {NAME} are looked up on the control’s this.options and then the window. For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control(\"Todos\",{\n  \"init\" : function( element , options ){ ... },\n  \"li click\" : function(li){ ... },\n\n  \"li .destroy {Events.destroy}\" : function(el, ev){ \n    // previous destroy code here\n  }\n})\n\n// Events config\nEvents = {destroy: \"click\"};\n\n// Events.destroy is looked up on the window.\nnew Todos(\"#todos\")\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<h2>Templated Event Handlers Pt 2 \"{objectName}\"</h2>\n\n<p>Controller can also bind to objects other than this.element with templated event handlers. This is critical for avoiding memory leaks that are so common among MVC applications.</p>\n\n<p>If the value inside {NAME} is an object, that object will be bound to. For example, the following tooltip listens to clicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  \"{window} click\" : function(el, ev){\n    // hide only if we clicked outside the tooltip\n    if(! this.element.has(ev.target ) {\n      this.element.remove();\n    }\n  }\n})\n\n// create a Tooltip\nnew Tooltip( $('&lt;div&gt;INFO&lt;/div&gt;').appendTo(el) )\n</code></pre>\n\n<p>This is convenient when needing to listen to model changes. If EJS was not taking care of removing <li>s after their model is destroyed, we could implement it in Todos like:</p>\n\n<pre><code>var Todos = can.Control({\n  \"init\" : function( element , options ){\n    var self = this;\n    Todo.findAll({}, function( todos ){\n      self.todosList = todos;\n      self.element.html(self.options.template, todos )\n    })\n  },\n  \"li click\" : function(li){\n    li.trigger('selected', li.model() );\n  },\n  \"li .destroy click\" : function(el, ev){\n    // get the li element that has todo data\n    var li = el.closest('li');\n\n    // get the model\n    var todo = li.data('todo')\n\n    //destroy it\n    todo.destroy();\n  },\n  \"{Todo} destroyed\" : funtion(Todo, ev, todoDestroyed) {\n    // find where the element\n    var index = this.todosList.indexOf(todoDestroyed)\n    this.element.children(\":nth-child(\"+(index+1)+\")\")\n        .remove()\n  }\n})\n\nnew Todos(\"#todos\");\n</code></pre>", "parents": ["index"], "plugin": "can/control", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/control/control.js", "test": "can/control/qunit.html", "inherits": "can.Construct", "description": "jQuery widget factory.", "src": "can/control/control.md", "children": ["can.Control.plugin", "can.Control.route"]})